{"version":3,"file":"liquid.min.js","sources":["../src/drop/drop.ts","../src/util/underscore.ts","../src/cache/lru.ts","../src/liquid-options.ts","../src/context/context.ts","../src/parser/token-kind.ts","../src/fs/browser.ts","../src/util/type-guards.ts","../src/util/character.ts","../src/parser/whitespace-ctrl.ts","../src/tokens/token.ts","../src/tokens/number-token.ts","../src/tokens/word-token.ts","../src/drop/empty-drop.ts","../src/drop/blank-drop.ts","../src/drop/null-drop.ts","../src/util/literal.ts","../src/tokens/literal-token.ts","../src/tokens/operator-token.ts","../src/tokens/property-access-token.ts","../src/util/error.ts","../src/util/assert.ts","../src/tokens/filter-token.ts","../src/tokens/hash-token.ts","../src/tokens/quoted-token.ts","../src/tokens/html-token.ts","../src/tokens/delimited-token.ts","../src/tokens/tag-token.ts","../src/tokens/range-token.ts","../src/tokens/output-token.ts","../src/parser/match-operator.ts","../src/parser/tokenizer.ts","../src/render/emitter.ts","../src/render/render.ts","../src/parser/parse-stream.ts","../src/template/template-impl.ts","../src/parser/parse-string-literal.ts","../src/drop/comparable.ts","../src/render/boolean.ts","../src/render/operator.ts","../src/render/expression.ts","../src/template/tag/hash.ts","../src/template/tag/tag.ts","../src/template/filter/filter.ts","../src/parser/filter-arg.ts","../src/template/value.ts","../src/template/output.ts","../src/template/html.ts","../src/parser/parser.ts","../src/builtin/tags/assign.ts","../src/util/collection.ts","../src/drop/forloop-drop.ts","../src/context/block-mode.ts","../src/builtin/tags/for.ts","../src/builtin/tags/capture.ts","../src/builtin/tags/case.ts","../src/builtin/tags/comment.ts","../src/builtin/tags/include.ts","../src/builtin/tags/render.ts","../src/builtin/tags/decrement.ts","../src/builtin/tags/cycle.ts","../src/builtin/tags/if.ts","../src/builtin/tags/increment.ts","../src/builtin/tags/layout.ts","../src/builtin/tags/block.ts","../src/builtin/tags/raw.ts","../src/drop/tablerowloop-drop.ts","../src/builtin/tags/index.ts","../src/builtin/tags/tablerow.ts","../src/builtin/tags/unless.ts","../src/builtin/tags/break.ts","../src/builtin/tags/continue.ts","../src/builtin/filters/html.ts","../src/builtin/filters/math.ts","../src/util/strftime.ts","../src/builtin/filters/url.ts","../src/builtin/filters/array.ts","../src/builtin/filters/date.ts","../src/builtin/filters/object.ts","../src/builtin/filters/string.ts","../src/template/tag/tag-map.ts","../src/template/filter/filter-map.ts","../src/util/async.ts","../src/liquid.ts"],"sourcesContent":["export abstract class Drop {\n  public valueOf (): any {\n    return undefined\n  }\n\n  public liquidMethodMissing (key: string): Promise<string | undefined> | string | undefined {\n    return undefined\n  }\n}\n","import { Drop } from '../drop/drop'\n\nconst toStr = Object.prototype.toString\nconst toLowerCase = String.prototype.toLowerCase\n\n/*\n * Checks if value is classified as a String primitive or object.\n * @param {any} value The value to check.\n * @return {Boolean} Returns true if value is a string, else false.\n */\nexport function isString (value: any): value is string {\n  return toStr.call(value) === '[object String]'\n}\n\nexport function isFunction (value: any): value is Function {\n  return typeof value === 'function'\n}\n\nexport function promisify<T1, T2> (fn: (arg1: T1, cb: (err: Error | null, result: T2) => void) => void): (arg1: T1) => Promise<T2>;\nexport function promisify<T1, T2, T3> (fn: (arg1: T1, arg2: T2, cb: (err: Error | null, result: T3) => void) => void): (arg1: T1, arg2: T2) => Promise<T3>;\nexport function promisify (fn: any) {\n  return function (...args: any[]) {\n    return new Promise((resolve, reject) => {\n      fn(...args, (err: Error, result: any) => {\n        err ? reject(err) : resolve(result)\n      })\n    })\n  }\n}\n\nexport function stringify (value: any): string {\n  value = toValue(value)\n  return isNil(value) ? '' : String(value)\n}\n\nexport function toValue (value: any): any {\n  return value instanceof Drop ? value.valueOf() : value\n}\n\nexport function isNumber (value: any): value is number {\n  return typeof value === 'number'\n}\n\nexport function toLiquid (value: any): any {\n  if (value && isFunction(value.toLiquid)) return toLiquid(value.toLiquid())\n  return value\n}\n\nexport function isNil (value: any): boolean {\n  return value === null || value === undefined\n}\n\nexport function isArray (value: any): value is any[] {\n  // be compatible with IE 8\n  return toStr.call(value) === '[object Array]'\n}\n\n/*\n * Iterates over own enumerable string keyed properties of an object and invokes iteratee for each property.\n * The iteratee is invoked with three arguments: (value, key, object).\n * Iteratee functions may exit iteration early by explicitly returning false.\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @return {Object} Returns object.\n */\nexport function forOwn <T> (\n  object: {[key: string]: T} | undefined,\n  iteratee: ((val: T, key: string, obj: {[key: string]: T}) => boolean | void)\n) {\n  object = object || {}\n  for (const k in object) {\n    if (object.hasOwnProperty(k)) {\n      if (iteratee(object[k], k, object) === false) break\n    }\n  }\n  return object\n}\n\nexport function last <T>(arr: T[]): T;\nexport function last (arr: string): string;\nexport function last (arr: any[] | string): any | string {\n  return arr[arr.length - 1]\n}\n\n/*\n * Checks if value is the language type of Object.\n * (e.g. arrays, functions, objects, regexes, new Number(0), and new String(''))\n * @param {any} value The value to check.\n * @return {Boolean} Returns true if value is an object, else false.\n */\nexport function isObject (value: any): value is object {\n  const type = typeof value\n  return value !== null && (type === 'object' || type === 'function')\n}\n\nexport function range (start: number, stop: number, step = 1) {\n  const arr: number[] = []\n  for (let i = start; i < stop; i += step) {\n    arr.push(i)\n  }\n  return arr\n}\n\nexport function padStart (str: any, length: number, ch = ' ') {\n  return pad(str, length, ch, (str, ch) => ch + str)\n}\n\nexport function padEnd (str: any, length: number, ch = ' ') {\n  return pad(str, length, ch, (str, ch) => str + ch)\n}\n\nexport function pad (str: any, length: number, ch: string, add: (str: string, ch: string) => string) {\n  str = String(str)\n  let n = length - str.length\n  while (n-- > 0) str = add(str, ch)\n  return str\n}\n\nexport function identify<T> (val: T): T {\n  return val\n}\n\nexport function snakeCase (str: string) {\n  return str.replace(\n    /(\\w?)([A-Z])/g,\n    (_, a, b) => (a ? a + '_' : '') + b.toLowerCase()\n  )\n}\n\nexport function changeCase (str: string): string {\n  const hasLowerCase = [...str].some(ch => ch >= 'a' && ch <= 'z')\n  return hasLowerCase ? str.toUpperCase() : str.toLowerCase()\n}\n\nexport function ellipsis (str: string, N: number): string {\n  return str.length > N ? str.substr(0, N - 3) + '...' : str\n}\n\n// compare string in case-insensitive way, undefined values to the tail\nexport function caseInsensitiveCompare (a: any, b: any) {\n  if (a == null && b == null) return 0\n  if (a == null) return 1\n  if (b == null) return -1\n  a = toLowerCase.call(a)\n  b = toLowerCase.call(b)\n  if (a < b) return -1\n  if (a > b) return 1\n  return 0\n}\n","import { Cache } from './cache'\n\nclass Node<T> {\n  constructor (\n    public key: string,\n    public value: T,\n    public next: Node<T>,\n    public prev: Node<T>\n  ) {}\n}\n\nexport class LRU<T> implements Cache<T> {\n  private cache: { [key: string]: Node<T> } = {}\n  private head: Node<T>\n  private tail: Node<T>\n\n  constructor (\n    public limit: number,\n    public size = 0\n  ) {\n    this.head = new Node<T>('HEAD', null as any, null as any, null as any)\n    this.tail = new Node<T>('TAIL', null as any, null as any, null as any)\n    this.head.next = this.tail\n    this.tail.prev = this.head\n  }\n\n  write (key: string, value: T) {\n    if (this.cache[key]) {\n      this.cache[key].value = value\n    } else {\n      const node = new Node(key, value, this.head.next, this.head)\n      this.head.next.prev = node\n      this.head.next = node\n\n      this.cache[key] = node\n      this.size++\n      this.ensureLimit()\n    }\n  }\n\n  read (key: string): T | undefined {\n    if (!this.cache[key]) return\n    const { value } = this.cache[key]\n    this.remove(key)\n    this.write(key, value)\n    return value\n  }\n\n  remove (key: string) {\n    const node = this.cache[key]\n    node.prev.next = node.next\n    node.next.prev = node.prev\n    delete this.cache[key]\n    this.size--\n  }\n\n  clear () {\n    this.head.next = this.tail\n    this.tail.prev = this.head\n    this.size = 0\n    this.cache = {}\n  }\n\n  private ensureLimit () {\n    if (this.size > this.limit) this.remove(this.tail.prev.key)\n  }\n}\n","import * as _ from './util/underscore'\nimport { Template } from './template/template'\nimport { Cache } from './cache/cache'\nimport { LRU } from './cache/lru'\nimport { FS } from './fs/fs'\n\nexport interface LiquidOptions {\n  /** A directory or an array of directories from where to resolve layout and include templates, and the filename passed to `.renderFile()`. If it's an array, the files are looked up in the order they occur in the array. Defaults to `[\".\"]` */\n  root?: string | string[];\n  /** Add a extname (if filepath doesn't include one) before template file lookup. Eg: setting to `\".html\"` will allow including file by basename. Defaults to `\"\"`. */\n  extname?: string;\n  /** Whether or not to cache resolved templates. Defaults to `false`. */\n  cache?: boolean | number | Cache<Template[]>;\n  /** If set, treat the `filepath` parameter in `{%include filepath %}` and `{%layout filepath%}` as a variable, otherwise as a literal value. Defaults to `true`. */\n  dynamicPartials?: boolean;\n  /** Whether or not to assert filter existence. If set to `false`, undefined filters will be skipped. Otherwise, undefined filters will cause an exception. Defaults to `false`. */\n  strictFilters?: boolean;\n  /** Whether or not to assert variable existence.  If set to `false`, undefined variables will be rendered as empty string.  Otherwise, undefined variables will cause an exception. Defaults to `false`. */\n  strictVariables?: boolean;\n  /** Strip blank characters (including ` `, `\\t`, and `\\r`) from the right of tags (`{% %}`) until `\\n` (inclusive). Defaults to `false`. */\n  trimTagRight?: boolean;\n  /** Similar to `trimTagRight`, whereas the `\\n` is exclusive. Defaults to `false`. See Whitespace Control for details. */\n  trimTagLeft?: boolean;\n  /** Strip blank characters (including ` `, `\\t`, and `\\r`) from the right of values (`{{ }}`) until `\\n` (inclusive). Defaults to `false`. */\n  trimOutputRight?: boolean;\n  /** Similar to `trimOutputRight`, whereas the `\\n` is exclusive. Defaults to `false`. See Whitespace Control for details. */\n  trimOutputLeft?: boolean;\n  /** The left delimiter for liquid tags. **/\n  tagDelimiterLeft?: string;\n  /** The right delimiter for liquid tags. **/\n  tagDelimiterRight?: string;\n  /** The left delimiter for liquid outputs. **/\n  outputDelimiterLeft?: string;\n  /** The right delimiter for liquid outputs. **/\n  outputDelimiterRight?: string;\n  /** Whether `trim*Left`/`trim*Right` is greedy. When set to `true`, all consecutive blank characters including `\\n` will be trimed regardless of line breaks. Defaults to `true`. */\n  greedy?: boolean;\n  /** `fs` is used to override the default file-system module with a custom implementation. */\n  fs?: FS;\n  /** the global environment passed down to all partial templates, i.e. templates included by `include`, `layout` and `render` tags. */\n  globals?: object;\n}\n\ninterface NormalizedOptions extends LiquidOptions {\n  root?: string[];\n  cache?: Cache<Template[]>;\n}\n\nexport interface NormalizedFullOptions extends NormalizedOptions {\n  root: string[];\n  extname: string;\n  cache: undefined | Cache<Template[]>;\n  dynamicPartials: boolean;\n  strictFilters: boolean;\n  strictVariables: boolean;\n  trimTagRight: boolean;\n  trimTagLeft: boolean;\n  trimOutputRight: boolean;\n  trimOutputLeft: boolean;\n  tagDelimiterLeft: string;\n  tagDelimiterRight: string;\n  outputDelimiterLeft: string;\n  outputDelimiterRight: string;\n  greedy: boolean;\n  globals: object;\n}\n\nexport const defaultOptions: NormalizedFullOptions = {\n  root: ['.'],\n  cache: undefined,\n  extname: '',\n  dynamicPartials: true,\n  trimTagRight: false,\n  trimTagLeft: false,\n  trimOutputRight: false,\n  trimOutputLeft: false,\n  greedy: true,\n  tagDelimiterLeft: '{%',\n  tagDelimiterRight: '%}',\n  outputDelimiterLeft: '{{',\n  outputDelimiterRight: '}}',\n  strictFilters: false,\n  strictVariables: false,\n  globals: {}\n}\n\nexport function normalize (options?: LiquidOptions): NormalizedOptions {\n  options = options || {}\n  if (options.hasOwnProperty('root')) {\n    options.root = normalizeStringArray(options.root)\n  }\n  if (options.hasOwnProperty('cache')) {\n    let cache: Cache<Template[]> | undefined\n    if (typeof options.cache === 'number') cache = options.cache > 0 ? new LRU(options.cache) : undefined\n    else if (typeof options.cache === 'object') cache = options.cache\n    else cache = options.cache ? new LRU<Template[]>(1024) : undefined\n    options.cache = cache\n  }\n  return options as NormalizedOptions\n}\n\nexport function applyDefault (options: NormalizedOptions): NormalizedFullOptions {\n  return { ...defaultOptions, ...options }\n}\n\nexport function normalizeStringArray (value: any): string[] {\n  if (_.isArray(value)) return value as string[]\n  if (_.isString(value)) return [value as string]\n  return []\n}\n","import { Drop } from '../drop/drop'\nimport { __assign } from 'tslib'\nimport { NormalizedFullOptions, defaultOptions } from '../liquid-options'\nimport { Scope } from './scope'\nimport { isArray, isNil, isString, isFunction, toLiquid } from '../util/underscore'\n\nexport class Context {\n  private scopes: Scope[] = [{}]\n  private registers = {}\n  public environments: Scope\n  public globals: Scope\n  public sync: boolean\n  public opts: NormalizedFullOptions\n  public constructor (env: object = {}, opts: NormalizedFullOptions = defaultOptions, sync = false) {\n    this.sync = sync\n    this.opts = opts\n    this.globals = opts.globals\n    this.environments = env\n  }\n  public getRegister (key: string, defaultValue = {}) {\n    return (this.registers[key] = this.registers[key] || defaultValue)\n  }\n  public setRegister (key: string, value: any) {\n    return (this.registers[key] = value)\n  }\n  public saveRegister (...keys: string[]): [string, any][] {\n    return keys.map(key => [key, this.getRegister(key)])\n  }\n  public restoreRegister (keyValues: [string, any][]) {\n    return keyValues.forEach(([key, value]) => this.setRegister(key, value))\n  }\n  public getAll () {\n    return [this.globals, this.environments, ...this.scopes]\n      .reduce((ctx, val) => __assign(ctx, val), {})\n  }\n  public get (paths: string[]) {\n    const scope = this.findScope(paths[0])\n    return this.getFromScope(scope, paths)\n  }\n  public getFromScope (scope: object, paths: string[] | string) {\n    if (typeof paths === 'string') paths = paths.split('.')\n    return paths.reduce((scope, path) => {\n      scope = readProperty(scope, path)\n      if (isNil(scope) && this.opts.strictVariables) {\n        throw new TypeError(`undefined variable: ${path}`)\n      }\n      return scope\n    }, scope)\n  }\n  public push (ctx: object) {\n    return this.scopes.push(ctx)\n  }\n  public pop () {\n    return this.scopes.pop()\n  }\n  public bottom () {\n    return this.scopes[0]\n  }\n  private findScope (key: string) {\n    for (let i = this.scopes.length - 1; i >= 0; i--) {\n      const candidate = this.scopes[i]\n      if (key in candidate) return candidate\n    }\n    if (key in this.environments) return this.environments\n    return this.globals\n  }\n}\n\nexport function readProperty (obj: Scope, key: string) {\n  if (isNil(obj)) return obj\n  obj = toLiquid(obj)\n  if (obj instanceof Drop) {\n    if (isFunction(obj[key])) return obj[key]()\n    if (obj.hasOwnProperty(key)) return obj[key]\n    return obj.liquidMethodMissing(key)\n  }\n  if (key === 'size') return readSize(obj)\n  if (key === 'first') return readFirst(obj)\n  if (key === 'last') return readLast(obj)\n  return obj[key]\n}\n\nfunction readFirst (obj: Scope) {\n  if (isArray(obj)) return obj[0]\n  return obj['first']\n}\n\nfunction readLast (obj: Scope) {\n  if (isArray(obj)) return obj[obj.length - 1]\n  return obj['last']\n}\n\nfunction readSize (obj: Scope) {\n  if (isArray(obj) || isString(obj)) return obj.length\n  return obj['size']\n}\n","export enum TokenKind {\n  Number = 1,\n  Literal = 2,\n  Tag = 4,\n  Output = 8,\n  HTML = 16,\n  Filter = 32,\n  Hash = 64,\n  PropertyAccess = 128,\n  Word = 256,\n  Range = 512,\n  Quoted = 1024,\n  Operator = 2048,\n  Delimited = Tag | Output\n}\n","import { last } from '../util/underscore'\n\nfunction domResolve (root: string, path: string) {\n  const base = document.createElement('base')\n  base.href = root\n\n  const head = document.getElementsByTagName('head')[0]\n  head.insertBefore(base, head.firstChild)\n\n  const a = document.createElement('a')\n  a.href = path\n  const resolved = a.href\n  head.removeChild(base)\n\n  return resolved\n}\n\nexport function resolve (root: string, filepath: string, ext: string) {\n  if (root.length && last(root) !== '/') root += '/'\n  const url = domResolve(root, filepath)\n  return url.replace(/^(\\w+:\\/\\/[^/]+)(\\/[^?]+)/, (str, origin, path) => {\n    const last = path.split('/').pop()\n    if (/\\.\\w+$/.test(last)) return str\n    return origin + path + ext\n  })\n}\n\nexport async function readFile (url: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest()\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText as string)\n      } else {\n        reject(new Error(xhr.statusText))\n      }\n    }\n    xhr.onerror = () => {\n      reject(new Error('An error occurred whilst receiving the response.'))\n    }\n    xhr.open('GET', url)\n    xhr.send()\n  })\n}\n\nexport function readFileSync (url: string): string {\n  const xhr = new XMLHttpRequest()\n  xhr.open('GET', url, false)\n  xhr.send()\n  if (xhr.status < 200 || xhr.status >= 300) {\n    throw new Error(xhr.statusText)\n  }\n  return xhr.responseText as string\n}\n\nexport async function exists (filepath: string) {\n  return true\n}\n\nexport function existsSync (filepath: string) {\n  return true\n}\n","import { OperatorToken } from '../tokens/operator-token'\nimport { DelimitedToken } from '../tokens/delimited-token'\nimport { WordToken } from '../tokens/word-token'\nimport { TagToken } from '../tokens/tag-token'\nimport { HTMLToken } from '../tokens/html-token'\nimport { OutputToken } from '../tokens/output-token'\nimport { PropertyAccessToken } from '../tokens/property-access-token'\nimport { LiteralToken } from '../tokens/literal-token'\nimport { QuotedToken } from '../tokens/quoted-token'\nimport { NumberToken } from '../tokens/number-token'\nimport { RangeToken } from '../tokens/range-token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport function isDelimitedToken (val: any): val is DelimitedToken {\n  return !!(getKind(val) & TokenKind.Delimited)\n}\n\nexport function isOperatorToken (val: any): val is OperatorToken {\n  return getKind(val) === TokenKind.Operator\n}\n\nexport function isHTMLToken (val: any): val is HTMLToken {\n  return getKind(val) === TokenKind.HTML\n}\n\nexport function isOutputToken (val: any): val is OutputToken {\n  return getKind(val) === TokenKind.Output\n}\n\nexport function isTagToken (val: any): val is TagToken {\n  return getKind(val) === TokenKind.Tag\n}\n\nexport function isQuotedToken (val: any): val is QuotedToken {\n  return getKind(val) === TokenKind.Quoted\n}\n\nexport function isLiteralToken (val: any): val is LiteralToken {\n  return getKind(val) === TokenKind.Literal\n}\n\nexport function isNumberToken (val: any): val is NumberToken {\n  return getKind(val) === TokenKind.Number\n}\n\nexport function isPropertyAccessToken (val: any): val is PropertyAccessToken {\n  return getKind(val) === TokenKind.PropertyAccess\n}\n\nexport function isWordToken (val: any): val is WordToken {\n  return getKind(val) === TokenKind.Word\n}\n\nexport function isRangeToken (val: any): val is RangeToken {\n  return getKind(val) === TokenKind.Range\n}\n\nfunction getKind (val: any) {\n  return val ? val.kind : -1\n}\n","// bitmask character types to boost performance\n// generated by bin/char-types.js\nexport const TYPES = [0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 4, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 8, 0, 0, 0, 0, 8, 0, 0, 0, 64, 0, 65, 0, 0, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 0, 0, 2, 2, 2, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]\nexport const VARIABLE = 1\nexport const OPERATOR = 2\nexport const BLANK = 4\nexport const QUOTE = 8\nexport const INLINE_BLANK = 16\nexport const NUMBER = 32\nexport const SIGN = 64\n","import { Token } from '../tokens/token'\nimport { isTagToken, isHTMLToken, isDelimitedToken } from '../util/type-guards'\nimport { NormalizedFullOptions } from '../liquid-options'\nimport { TYPES, INLINE_BLANK, BLANK } from '../util/character'\n\nexport function whiteSpaceCtrl (tokens: Token[], options: NormalizedFullOptions) {\n  options = { greedy: true, ...options }\n  let inRaw = false\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n    if (!isDelimitedToken(token)) continue\n    if (!inRaw && token.trimLeft) {\n      trimLeft(tokens[i - 1], options.greedy)\n    }\n\n    if (isTagToken(token)) {\n      if (token.name === 'raw') inRaw = true\n      else if (token.name === 'endraw') inRaw = false\n    }\n\n    if (!inRaw && token.trimRight) {\n      trimRight(tokens[i + 1], options.greedy)\n    }\n  }\n}\n\nfunction trimLeft (token: Token, greedy: boolean) {\n  if (!token || !isHTMLToken(token)) return\n\n  const mask = greedy ? BLANK : INLINE_BLANK\n  while (TYPES[token.input.charCodeAt(token.end - 1 - token.trimRight)] & mask) token.trimRight++\n}\n\nfunction trimRight (token: Token, greedy: boolean) {\n  if (!token || !isHTMLToken(token)) return\n\n  const mask = greedy ? BLANK : INLINE_BLANK\n  while (TYPES[token.input.charCodeAt(token.begin + token.trimLeft)] & mask) token.trimLeft++\n  if (token.input.charAt(token.begin + token.trimLeft) === '\\n') token.trimLeft++\n}\n","import { TokenKind } from '../parser/token-kind'\n\nexport abstract class Token {\n  public constructor (\n    public kind: TokenKind,\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {}\n  public getText () {\n    return this.input.slice(this.begin, this.end)\n  }\n  public getPosition () {\n    let [row, col] = [1, 1]\n    for (let i = 0; i < this.begin; i++) {\n      if (this.input[i] === '\\n') {\n        row++\n        col = 1\n      } else col++\n    }\n    return [row, col]\n  }\n  public size () {\n    return this.end - this.begin\n  }\n}\n","import { Token } from './token'\nimport { WordToken } from './word-token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class NumberToken extends Token {\n  constructor (\n    public whole: WordToken,\n    public decimal?: WordToken\n  ) {\n    super(TokenKind.Number, whole.input, whole.begin, decimal ? decimal.end : whole.end, whole.file)\n  }\n}\n","import { Token } from './token'\nimport { NUMBER, TYPES, SIGN } from '../util/character'\nimport { TokenKind } from '../parser/token-kind'\n\n// a word can be an identifier, a number, a keyword or a single-word-literal\nexport class WordToken extends Token {\n  public content: string\n  constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {\n    super(TokenKind.Word, input, begin, end, file)\n    this.content = this.getText()\n  }\n  isNumber (allowSign = false) {\n    const begin = allowSign && TYPES[this.input.charCodeAt(this.begin)] & SIGN\n      ? this.begin + 1\n      : this.begin\n    for (let i = begin; i < this.end; i++) {\n      if (!(TYPES[this.input.charCodeAt(i)] & NUMBER)) return false\n    }\n    return true\n  }\n}\n","import { Drop } from './drop'\nimport { Comparable } from './comparable'\nimport { isObject, isString, isArray } from '../util/underscore'\n\nexport class EmptyDrop extends Drop implements Comparable {\n  public equals (value: any) {\n    if (isString(value) || isArray(value)) return value.length === 0\n    if (isObject(value)) return Object.keys(value).length === 0\n    return false\n  }\n  public gt () {\n    return false\n  }\n  public geq () {\n    return false\n  }\n  public lt () {\n    return false\n  }\n  public leq () {\n    return false\n  }\n  public valueOf () {\n    return ''\n  }\n}\n","import { isNil, isString, toValue } from '../util/underscore'\nimport { EmptyDrop } from '../drop/empty-drop'\n\nexport class BlankDrop extends EmptyDrop {\n  public equals (value: any) {\n    if (value === false) return true\n    if (isNil(toValue(value))) return true\n    if (isString(value)) return /^\\s*$/.test(value)\n    return super.equals(value)\n  }\n}\n","import { Drop } from './drop'\nimport { Comparable } from './comparable'\nimport { isNil, toValue } from '../util/underscore'\nimport { BlankDrop } from '../drop/blank-drop'\n\nexport class NullDrop extends Drop implements Comparable {\n  public equals (value: any) {\n    return isNil(toValue(value)) || value instanceof BlankDrop\n  }\n  public gt () {\n    return false\n  }\n  public geq () {\n    return false\n  }\n  public lt () {\n    return false\n  }\n  public leq () {\n    return false\n  }\n  public valueOf () {\n    return null\n  }\n}\n","import { NullDrop } from '../drop/null-drop'\nimport { EmptyDrop } from '../drop/empty-drop'\nimport { BlankDrop } from '../drop/blank-drop'\n\nexport const literalValues = {\n  'true': true,\n  'false': false,\n  'nil': new NullDrop(),\n  'null': new NullDrop(),\n  'empty': new EmptyDrop(),\n  'blank': new BlankDrop()\n}\n","import { Token } from './token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class LiteralToken extends Token {\n  public literal: string\n  public constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {\n    super(TokenKind.Literal, input, begin, end, file)\n    this.literal = this.getText()\n  }\n}\n","import { Token } from './token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport const precedence = {\n  '==': 1,\n  '!=': 1,\n  '>': 1,\n  '<': 1,\n  '>=': 1,\n  '<=': 1,\n  'contains': 1,\n  'and': 0,\n  'or': 0\n}\n\nexport class OperatorToken extends Token {\n  public operator: string\n  public constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {\n    super(TokenKind.Operator, input, begin, end, file)\n    this.operator = this.getText()\n  }\n  getPrecedence () {\n    return precedence[this.getText()]\n  }\n}\n","import { Token } from './token'\nimport { WordToken } from './word-token'\nimport { QuotedToken } from './quoted-token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class PropertyAccessToken extends Token {\n  constructor (\n    public variable: WordToken,\n    public props: (WordToken | QuotedToken | PropertyAccessToken)[],\n    end: number\n  ) {\n    super(TokenKind.PropertyAccess, variable.input, variable.begin, end, variable.file)\n  }\n}\n","import * as _ from './underscore'\nimport { Token } from '../tokens/token'\nimport { Template } from '../template/template'\n\nabstract class LiquidError extends Error {\n  private token: Token\n  private originalError: Error\n  public constructor (err: Error, token: Token) {\n    super(err.message)\n    this.originalError = err\n    this.token = token\n  }\n  protected update () {\n    const err = this.originalError\n    const context = mkContext(this.token)\n    this.message = mkMessage(err.message, this.token)\n    this.stack = this.message + '\\n' + context +\n      '\\n' + this.stack + '\\nFrom ' + err.stack\n  }\n}\n\nexport class TokenizationError extends LiquidError {\n  public constructor (message: string, token: Token) {\n    super(new Error(message), token)\n    this.name = 'TokenizationError'\n    super.update()\n  }\n}\n\nexport class ParseError extends LiquidError {\n  public constructor (err: Error, token: Token) {\n    super(err, token)\n    this.name = 'ParseError'\n    this.message = err.message\n    super.update()\n  }\n}\n\nexport class RenderError extends LiquidError {\n  public constructor (err: Error, tpl: Template) {\n    super(err, tpl.token)\n    this.name = 'RenderError'\n    this.message = err.message\n    super.update()\n  }\n  public static is (obj: any): obj is RenderError {\n    return obj instanceof RenderError\n  }\n}\n\nexport class AssertionError extends Error {\n  public constructor (message: string) {\n    super(message)\n    this.name = 'AssertionError'\n    this.message = message + ''\n  }\n}\n\nfunction mkContext (token: Token) {\n  const [line] = token.getPosition()\n  const lines = token.input.split('\\n')\n  const begin = Math.max(line - 2, 1)\n  const end = Math.min(line + 3, lines.length)\n\n  const context = _\n    .range(begin, end + 1)\n    .map(lineNumber => {\n      const indicator = (lineNumber === line) ? '>> ' : '   '\n      const num = _.padStart(String(lineNumber), String(end).length)\n      const text = lines[lineNumber - 1]\n      return `${indicator}${num}| ${text}`\n    })\n    .join('\\n')\n\n  return context\n}\n\nfunction mkMessage (msg: string, token: Token) {\n  if (token.file) msg += `, file:${token.file}`\n  const [line, col] = token.getPosition()\n  msg += `, line:${line}, col:${col}`\n  return msg\n}\n","import { AssertionError } from './error'\n\nexport function assert <T> (predicate: T | null | undefined, message?: () => string) {\n  if (!predicate) {\n    const msg = message ? message() : `expect ${predicate} to be true`\n    throw new AssertionError(msg)\n  }\n}\n","import { Token } from './token'\nimport { FilterArg } from '../parser/filter-arg'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class FilterToken extends Token {\n  public constructor (\n    public name: string,\n    public args: FilterArg[],\n    input: string,\n    begin: number,\n    end: number,\n    file?: string\n  ) {\n    super(TokenKind.Filter, input, begin, end, file)\n  }\n}\n","import { Token } from './token'\nimport { ValueToken } from './value-token'\nimport { WordToken } from './word-token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class HashToken extends Token {\n  constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public name: WordToken,\n    public value?: ValueToken,\n    public file?: string\n  ) {\n    super(TokenKind.Hash, input, begin, end, file)\n  }\n}\n","import { Token } from './token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class QuotedToken extends Token {\n  constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {\n    super(TokenKind.Quoted, input, begin, end, file)\n  }\n}\n","import { Token } from './token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class HTMLToken extends Token {\n  trimLeft = 0\n  trimRight = 0\n  constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public file?: string\n  ) {\n    super(TokenKind.HTML, input, begin, end, file)\n  }\n  public getContent () {\n    return this.input.slice(this.begin + this.trimLeft, this.end - this.trimRight)\n  }\n}\n","import { Token } from './token'\nimport { TokenKind } from '../parser/token-kind'\nimport { last } from '../util/underscore'\n\nexport abstract class DelimitedToken extends Token {\n  public trimLeft = false\n  public trimRight = false\n  public content: string\n  public constructor (\n    kind: TokenKind,\n    content: string,\n    input: string,\n    begin: number,\n    end: number,\n    trimLeft: boolean,\n    trimRight: boolean,\n    file?: string\n  ) {\n    super(kind, input, begin, end, file)\n    this.content = this.getText()\n    const tl = content[0] === '-'\n    const tr = last(content) === '-'\n    this.content = content\n      .slice(\n        tl ? 1 : 0,\n        tr ? -1 : content.length\n      )\n      .trim()\n    this.trimLeft = tl || trimLeft\n    this.trimRight = tr || trimRight\n  }\n}\n","import { DelimitedToken } from './delimited-token'\nimport { BLANK, TYPES, VARIABLE } from '../util/character'\nimport { TokenizationError } from '../util/error'\nimport { NormalizedFullOptions } from '../liquid-options'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class TagToken extends DelimitedToken {\n  public name: string\n  public args: string\n  public constructor (\n    input: string,\n    begin: number,\n    end: number,\n    options: NormalizedFullOptions,\n    file?: string\n  ) {\n    const { trimTagLeft, trimTagRight, tagDelimiterLeft, tagDelimiterRight } = options\n    const value = input.slice(begin + tagDelimiterLeft.length, end - tagDelimiterRight.length)\n    super(TokenKind.Tag, value, input, begin, end, trimTagLeft, trimTagRight, file)\n\n    let nameEnd = 0\n    while (TYPES[this.content.charCodeAt(nameEnd)] & VARIABLE) nameEnd++\n    this.name = this.content.slice(0, nameEnd)\n    if (!this.name) throw new TokenizationError(`illegal tag syntax`, this)\n\n    let argsBegin = nameEnd\n    while (TYPES[this.content.charCodeAt(argsBegin)] & BLANK) argsBegin++\n    this.args = this.content.slice(argsBegin)\n  }\n}\n","import { Token } from './token'\nimport { ValueToken } from './value-token'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class RangeToken extends Token {\n  constructor (\n    public input: string,\n    public begin: number,\n    public end: number,\n    public lhs: ValueToken,\n    public rhs: ValueToken,\n    public file?: string\n  ) {\n    super(TokenKind.Range, input, begin, end, file)\n  }\n}\n","import { DelimitedToken } from './delimited-token'\nimport { NormalizedFullOptions } from '../liquid-options'\nimport { TokenKind } from '../parser/token-kind'\n\nexport class OutputToken extends DelimitedToken {\n  public constructor (\n    input: string,\n    begin: number,\n    end: number,\n    options: NormalizedFullOptions,\n    file?: string\n  ) {\n    const { trimOutputLeft, trimOutputRight, outputDelimiterLeft, outputDelimiterRight } = options\n    const value = input.slice(begin + outputDelimiterLeft.length, end - outputDelimiterRight.length)\n    super(TokenKind.Output, value, input, begin, end, trimOutputLeft, trimOutputRight, file)\n  }\n}\n","import { VARIABLE } from '../util/character'\n\nconst trie = {\n  a: { n: { d: { end: true, needBoundary: true } } },\n  o: { r: { end: true, needBoundary: true } },\n  c: { o: { n: { t: { a: { i: { n: { s: { end: true, needBoundary: true } } } } } } } },\n  '=': { '=': { end: true } },\n  '!': { '=': { end: true } },\n  '>': { end: true, '=': { end: true } },\n  '<': { end: true, '=': { end: true } }\n}\n\nexport function matchOperator (str: string, begin: number, end = str.length) {\n  let node = trie\n  let i = begin\n  let info\n  while (node[str[i]] && i < end) {\n    node = node[str[i++]]\n    if (node['end']) info = node\n  }\n  if (!info) return -1\n  if (info['needBoundary'] && str.charCodeAt(i) & VARIABLE) return -1\n  return i\n}\n","import { whiteSpaceCtrl } from './whitespace-ctrl'\nimport { NumberToken } from '../tokens/number-token'\nimport { WordToken } from '../tokens/word-token'\nimport { literalValues } from '../util/literal'\nimport { LiteralToken } from '../tokens/literal-token'\nimport { OperatorToken } from '../tokens/operator-token'\nimport { PropertyAccessToken } from '../tokens/property-access-token'\nimport { assert } from '../util/assert'\nimport { TopLevelToken } from '../tokens/toplevel-token'\nimport { FilterArg } from './filter-arg'\nimport { FilterToken } from '../tokens/filter-token'\nimport { HashToken } from '../tokens/hash-token'\nimport { QuotedToken } from '../tokens/quoted-token'\nimport { ellipsis } from '../util/underscore'\nimport { HTMLToken } from '../tokens/html-token'\nimport { TagToken } from '../tokens/tag-token'\nimport { Token } from '../tokens/token'\nimport { RangeToken } from '../tokens/range-token'\nimport { ValueToken } from '../tokens/value-token'\nimport { OutputToken } from '../tokens/output-token'\nimport { TokenizationError } from '../util/error'\nimport { NormalizedFullOptions, defaultOptions } from '../liquid-options'\nimport { TYPES, QUOTE, BLANK, VARIABLE } from '../util/character'\nimport { matchOperator } from './match-operator'\n\nexport class Tokenizer {\n  p = 0\n  N: number\n  constructor (\n    private input: string,\n    private file: string = ''\n  ) {\n    this.N = input.length\n  }\n\n  * readExpression (): IterableIterator<Token> {\n    const operand = this.readValue()\n    if (!operand) return\n\n    yield operand\n\n    while (this.p < this.N) {\n      const operator = this.readOperator()\n      if (!operator) return\n\n      const operand = this.readValue()\n      if (!operand) return\n\n      yield operator\n      yield operand\n    }\n  }\n  readOperator (): OperatorToken | undefined {\n    this.skipBlank()\n    const end = matchOperator(this.input, this.p, this.p + 8)\n    if (end === -1) return\n    return new OperatorToken(this.input, this.p, (this.p = end), this.file)\n  }\n  readFilters (): FilterToken[] {\n    const filters = []\n    while (true) {\n      const filter = this.readFilter()\n      if (!filter) return filters\n      filters.push(filter)\n    }\n  }\n  readFilter (): FilterToken | null {\n    this.skipBlank()\n    if (this.end()) return null\n    assert(this.peek() === '|', () => `unexpected token at ${this.snapshot()}`)\n    this.p++\n    const begin = this.p\n    const name = this.readWord()\n    if (!name.size()) return null\n    const args = []\n    this.skipBlank()\n    if (this.peek() === ':') {\n      do {\n        ++this.p\n        const arg = this.readFilterArg()\n        arg && args.push(arg)\n        while (this.p < this.N && this.peek() !== ',' && this.peek() !== '|') ++this.p\n      } while (this.peek() === ',')\n    }\n    return new FilterToken(name.getText(), args, this.input, begin, this.p, this.file)\n  }\n\n  readFilterArg (): FilterArg | undefined {\n    const key = this.readValue()\n    if (!key) return\n    this.skipBlank()\n    if (this.peek() !== ':') return key\n    ++this.p\n    const value = this.readValue()\n    return [key.getText(), value]\n  }\n\n  readTopLevelTokens (options: NormalizedFullOptions = defaultOptions): TopLevelToken[] {\n    const tokens: TopLevelToken[] = []\n    while (this.p < this.N) {\n      const token = this.readTopLevelToken(options)\n      tokens.push(token)\n    }\n    whiteSpaceCtrl(tokens, options)\n    return tokens\n  }\n\n  readTopLevelToken (options: NormalizedFullOptions): TopLevelToken {\n    const { tagDelimiterLeft, outputDelimiterLeft } = options\n    if (this.matchWord(tagDelimiterLeft)) return this.readTagToken(options)\n    if (this.matchWord(outputDelimiterLeft)) return this.readOutputToken(options)\n    return this.readHTMLToken(options)\n  }\n\n  readHTMLToken (options: NormalizedFullOptions): HTMLToken {\n    const begin = this.p\n    while (this.p < this.N) {\n      const { tagDelimiterLeft, outputDelimiterLeft } = options\n      if (this.matchWord(tagDelimiterLeft)) break\n      if (this.matchWord(outputDelimiterLeft)) break\n      ++this.p\n    }\n    return new HTMLToken(this.input, begin, this.p, this.file)\n  }\n\n  readTagToken (options: NormalizedFullOptions): TagToken {\n    const { file, input } = this\n    const { tagDelimiterRight } = options\n    const begin = this.p\n    if (this.readTo(tagDelimiterRight) === -1) {\n      this.mkError(`tag ${this.snapshot(begin)} not closed`, begin)\n    }\n    return new TagToken(input, begin, this.p, options, file)\n  }\n\n  readOutputToken (options: NormalizedFullOptions): OutputToken {\n    const { file, input } = this\n    const { outputDelimiterRight } = options\n    const begin = this.p\n    if (this.readTo(outputDelimiterRight) === -1) {\n      this.mkError(`output ${this.snapshot(begin)} not closed`, begin)\n    }\n    return new OutputToken(input, begin, this.p, options, file)\n  }\n\n  mkError (msg: string, begin: number) {\n    throw new TokenizationError(msg, new WordToken(this.input, begin, this.N, this.file))\n  }\n\n  snapshot (begin: number = this.p) {\n    return JSON.stringify(ellipsis(this.input.slice(begin), 16))\n  }\n\n  readWord (): WordToken { // rename to identifier\n    this.skipBlank()\n    const begin = this.p\n    while (this.peekType() & VARIABLE) ++this.p\n    return new WordToken(this.input, begin, this.p, this.file)\n  }\n\n  readHashes () {\n    const hashes = []\n    while (true) {\n      const hash = this.readHash()\n      if (!hash) return hashes\n      hashes.push(hash)\n    }\n  }\n\n  readHash (): HashToken | undefined {\n    this.skipBlank()\n    if (this.peek() === ',') ++this.p\n    const begin = this.p\n    const name = this.readWord()\n    if (!name.size()) return\n    let value\n\n    this.skipBlank()\n    if (this.peek() === ':') {\n      ++this.p\n      value = this.readValue()\n    }\n    return new HashToken(this.input, begin, this.p, name, value, this.file)\n  }\n\n  remaining () {\n    return this.input.slice(this.p)\n  }\n\n  advance (i = 1) {\n    this.p += i\n  }\n\n  end () {\n    return this.p >= this.N\n  }\n\n  readTo (end: string): number {\n    while (this.p < this.N) {\n      ++this.p\n      if (this.reverseMatchWord(end)) return this.p\n    }\n    return -1\n  }\n\n  readValue (): ValueToken | undefined {\n    const value = this.readQuoted() || this.readRange()\n    if (value) return value\n\n    const variable = this.readWord()\n    if (!variable.size()) return\n\n    let isNumber = variable.isNumber(true)\n    const props: (QuotedToken | WordToken)[] = []\n    while (true) {\n      if (this.peek() === '[') {\n        isNumber = false\n        this.p++\n        const prop = this.readValue() || new WordToken(this.input, this.p, this.p, this.file)\n        this.readTo(']')\n        props.push(prop)\n      } else if (this.peek() === '.' && this.peek(1) !== '.') { // skip range syntax\n        this.p++\n        const prop = this.readWord()\n        if (!prop.size()) break\n        if (!prop.isNumber()) isNumber = false\n        props.push(prop)\n      } else break\n    }\n    if (!props.length && literalValues.hasOwnProperty(variable.content)) {\n      return new LiteralToken(this.input, variable.begin, variable.end, this.file)\n    }\n    if (isNumber) return new NumberToken(variable, props[0] as WordToken)\n    return new PropertyAccessToken(variable, props, this.p)\n  }\n\n  readRange (): RangeToken | undefined {\n    this.skipBlank()\n    const begin = this.p\n    if (this.peek() !== '(') return\n    ++this.p\n    const lhs = this.readValueOrThrow()\n    this.p += 2\n    const rhs = this.readValueOrThrow()\n    ++this.p\n    return new RangeToken(this.input, begin, this.p, lhs, rhs, this.file)\n  }\n\n  readValueOrThrow (): ValueToken {\n    const value = this.readValue()\n    assert(value, () => `unexpected token ${this.snapshot()}, value expected`)\n    return value!\n  }\n\n  readQuoted (): QuotedToken | undefined {\n    this.skipBlank()\n    const begin = this.p\n    if (!(this.peekType() & QUOTE)) return\n    ++this.p\n    let escaped = false\n    while (this.p < this.N) {\n      ++this.p\n      if (this.input[this.p - 1] === this.input[begin] && !escaped) break\n      if (escaped) escaped = false\n      else if (this.input[this.p - 1] === '\\\\') escaped = true\n    }\n    return new QuotedToken(this.input, begin, this.p, this.file)\n  }\n\n  readFileName (): WordToken {\n    const begin = this.p\n    while (!(this.peekType() & BLANK) && this.peek() !== ',' && this.p < this.N) this.p++\n    return new WordToken(this.input, begin, this.p, this.file)\n  }\n\n  matchWord (word: string) {\n    for (let i = 0; i < word.length; i++) {\n      if (word[i] !== this.input[this.p + i]) return false\n    }\n    return true\n  }\n\n  reverseMatchWord (word: string) {\n    for (let i = 0; i < word.length; i++) {\n      if (word[word.length - 1 - i] !== this.input[this.p - 1 - i]) return false\n    }\n    return true\n  }\n\n  peekType (n = 0) {\n    return TYPES[this.input.charCodeAt(this.p + n)]\n  }\n\n  peek (n = 0) {\n    return this.input[this.p + n]\n  }\n\n  skipBlank () {\n    while (this.peekType() & BLANK) ++this.p\n  }\n}\n","export class Emitter {\n  public html = '';\n  public break = false;\n  public continue = false;\n\n  public write (html: string) {\n    this.html += html\n  }\n}\n","import { RenderError } from '../util/error'\nimport { Context } from '../context/context'\nimport { Template } from '../template/template'\nimport { Emitter } from './emitter'\n\nexport class Render {\n  public * renderTemplates (templates: Template[], ctx: Context, emitter = new Emitter()): IterableIterator<string> {\n    for (const tpl of templates) {\n      try {\n        const html = yield tpl.render(ctx, emitter)\n        html && emitter.write(html)\n        if (emitter.break || emitter.continue) break\n      } catch (e) {\n        const err = RenderError.is(e) ? e : new RenderError(e, tpl)\n        throw err\n      }\n    }\n    return emitter.html\n  }\n}\n","import { Token } from '../tokens/token'\nimport { Template } from '../template/template'\nimport { isTagToken } from '../util/type-guards'\nimport { TopLevelToken } from '../tokens/toplevel-token'\n\ntype ParseToken<T extends Token> = ((token: T, remainTokens: T[]) => Template)\n\nexport class ParseStream<T extends Token = TopLevelToken> {\n  private tokens: T[]\n  private handlers: {[key: string]: (arg: any) => void} = {}\n  private stopRequested = false\n  private parseToken: ParseToken<T>\n\n  public constructor (tokens: T[], parseToken: ParseToken<T>) {\n    this.tokens = tokens\n    this.parseToken = parseToken\n  }\n  public on<T2 extends Template | T | undefined> (name: string, cb: (arg: T2) => void): ParseStream<T> {\n    this.handlers[name] = cb\n    return this\n  }\n  private trigger <T extends Token | Template> (event: string, arg?: T) {\n    const h = this.handlers[event]\n    return h ? (h(arg), true) : false\n  }\n  public start () {\n    this.trigger('start')\n    let token: T | undefined\n    while (!this.stopRequested && (token = this.tokens.shift())) {\n      if (this.trigger('token', token)) continue\n      if (isTagToken(token) && this.trigger(`tag:${token.name}`, token)) {\n        continue\n      }\n      const template = this.parseToken(token, this.tokens)\n      this.trigger('template', template)\n    }\n    if (!this.stopRequested) this.trigger('end')\n    return this\n  }\n  public stop () {\n    this.stopRequested = true\n    return this\n  }\n}\n","export abstract class TemplateImpl<T> {\n  public token: T;\n  public constructor (token: T) {\n    this.token = token\n  }\n}\n","const rHex = /[\\da-fA-F]/\nconst rOct = /[0-7]/\nconst escapeChar = {\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n  v: '\\x0B'\n}\n\nfunction hexVal (c: string) {\n  const code = c.charCodeAt(0)\n  if (code >= 97) return code - 87\n  if (code >= 65) return code - 55\n  return code - 48\n}\n\nexport function parseStringLiteral (str: string): string {\n  let ret = ''\n  for (let i = 1; i < str.length - 1; i++) {\n    if (str[i] !== '\\\\') {\n      ret += str[i]\n      continue\n    }\n    if (escapeChar[str[i + 1]] !== undefined) {\n      ret += escapeChar[str[++i]]\n    } else if (str[i + 1] === 'u') {\n      let val = 0\n      let j = i + 2\n      while (j <= i + 5 && rHex.test(str[j])) {\n        val = val * 16 + hexVal(str[j++])\n      }\n      i = j - 1\n      ret += String.fromCharCode(val)\n    } else if (!rOct.test(str[i + 1])) {\n      ret += str[++i]\n    } else {\n      let j = i + 1\n      let val = 0\n      while (j <= i + 3 && rOct.test(str[j])) {\n        val = val * 8 + hexVal(str[j++])\n      }\n      i = j - 1\n      ret += String.fromCharCode(val)\n    }\n  }\n  return ret\n}\n\n","import { isFunction } from '../util/underscore'\n\nexport interface Comparable {\n  equals: (rhs: any) => boolean;\n  gt: (rhs: any) => boolean;\n  geq: (rhs: any) => boolean;\n  lt: (rhs: any) => boolean;\n  leq: (rhs: any) => boolean;\n}\n\nexport function isComparable (arg: any): arg is Comparable {\n  return arg && isFunction(arg.equals)\n}\n","export function isTruthy (val: any): boolean {\n  return !isFalsy(val)\n}\nexport function isFalsy (val: any): boolean {\n  return val === false || undefined === val || val === null\n}\n","import { isComparable } from '../drop/comparable'\nimport { isFunction } from '../util/underscore'\nimport { isTruthy } from '../render/boolean'\n\nexport const operatorImpls: {[key: string]: (lhs: any, rhs: any) => boolean} = {\n  '==': (l: any, r: any) => {\n    if (isComparable(l)) return l.equals(r)\n    if (isComparable(r)) return r.equals(l)\n    return l === r\n  },\n  '!=': (l: any, r: any) => {\n    if (isComparable(l)) return !l.equals(r)\n    if (isComparable(r)) return !r.equals(l)\n    return l !== r\n  },\n  '>': (l: any, r: any) => {\n    if (isComparable(l)) return l.gt(r)\n    if (isComparable(r)) return r.lt(l)\n    return l > r\n  },\n  '<': (l: any, r: any) => {\n    if (isComparable(l)) return l.lt(r)\n    if (isComparable(r)) return r.gt(l)\n    return l < r\n  },\n  '>=': (l: any, r: any) => {\n    if (isComparable(l)) return l.geq(r)\n    if (isComparable(r)) return r.leq(l)\n    return l >= r\n  },\n  '<=': (l: any, r: any) => {\n    if (isComparable(l)) return l.leq(r)\n    if (isComparable(r)) return r.geq(l)\n    return l <= r\n  },\n  'contains': (l: any, r: any) => {\n    return l && isFunction(l.indexOf) ? l.indexOf(r) > -1 : false\n  },\n  'and': (l: any, r: any) => isTruthy(l) && isTruthy(r),\n  'or': (l: any, r: any) => isTruthy(l) || isTruthy(r)\n}\n","import { QuotedToken } from '../tokens/quoted-token'\nimport { NumberToken } from '../tokens/number-token'\nimport { assert } from '../util/assert'\nimport { literalValues } from '../util/literal'\nimport { LiteralToken } from '../tokens/literal-token'\nimport * as TypeGuards from '../util/type-guards'\nimport { Token } from '../tokens/token'\nimport { OperatorToken } from '../tokens/operator-token'\nimport { RangeToken } from '../tokens/range-token'\nimport { parseStringLiteral } from '../parser/parse-string-literal'\nimport { Context } from '../context/context'\nimport { range, toValue } from '../util/underscore'\nimport { Tokenizer } from '../parser/tokenizer'\nimport { operatorImpls } from '../render/operator'\n\nexport class Expression {\n  private operands: any[] = []\n  private postfix: IterableIterator<Token>\n\n  public constructor (str: string) {\n    const tokenizer = new Tokenizer(str)\n    this.postfix = toPostfix(tokenizer.readExpression())\n  }\n  public evaluate (ctx: Context): any {\n    for (const token of this.postfix) {\n      if (TypeGuards.isOperatorToken(token)) {\n        const r = this.operands.pop()\n        const l = this.operands.pop()\n        const result = evalOperatorToken(token, l, r)\n        this.operands.push(result)\n      } else {\n        this.operands.push(evalToken(token, ctx))\n      }\n    }\n    return this.operands[0]\n  }\n  public * value (ctx: Context) {\n    return toValue(this.evaluate(ctx))\n  }\n}\n\nexport function evalToken (token: Token | undefined, ctx: Context): any {\n  assert(ctx, () => 'unable to evaluate: context not defined')\n  if (TypeGuards.isPropertyAccessToken(token)) {\n    const variable = token.variable.getText()\n    const props: string[] = token.props.map(prop => evalToken(prop, ctx))\n    return ctx.get([variable, ...props])\n  }\n  if (TypeGuards.isRangeToken(token)) return evalRangeToken(token, ctx)\n  if (TypeGuards.isLiteralToken(token)) return evalLiteralToken(token)\n  if (TypeGuards.isNumberToken(token)) return evalNumberToken(token)\n  if (TypeGuards.isWordToken(token)) return token.getText()\n  if (TypeGuards.isQuotedToken(token)) return evalQuotedToken(token)\n}\n\nfunction evalNumberToken (token: NumberToken) {\n  const str = token.whole.content + '.' + (token.decimal ? token.decimal.content : '')\n  return Number(str)\n}\n\nexport function evalQuotedToken (token: QuotedToken) {\n  return parseStringLiteral(token.getText())\n}\n\nfunction evalOperatorToken (token: OperatorToken, lhs: any, rhs: any) {\n  const impl = operatorImpls[token.operator]\n  return impl(lhs, rhs)\n}\n\nfunction evalLiteralToken (token: LiteralToken) {\n  return literalValues[token.literal]\n}\n\nfunction evalRangeToken (token: RangeToken, ctx: Context) {\n  const low: number = evalToken(token.lhs, ctx)\n  const high: number = evalToken(token.rhs, ctx)\n  return range(+low, +high + 1)\n}\n\nfunction * toPostfix (tokens: IterableIterator<Token>): IterableIterator<Token> {\n  const ops: OperatorToken[] = []\n  for (const token of tokens) {\n    if (TypeGuards.isOperatorToken(token)) {\n      while (ops.length && ops[ops.length - 1].getPrecedence() > token.getPrecedence()) {\n        yield ops.pop()!\n      }\n      ops.push(token)\n    } else yield token\n  }\n  while (ops.length) {\n    yield ops.pop()!\n  }\n}\n","import { evalToken } from '../../render/expression'\nimport { Context } from '../../context/context'\nimport { Tokenizer } from '../../parser/tokenizer'\n\n/**\n * Key-Value Pairs Representing Tag Arguments\n * Example:\n *    For the markup `, foo:'bar', coo:2 reversed %}`,\n *    hash['foo'] === 'bar'\n *    hash['coo'] === 2\n *    hash['reversed'] === undefined\n */\nexport class Hash {\n  hash: { [key: string]: any } = {}\n  constructor (markup: string) {\n    const tokenizer = new Tokenizer(markup)\n    for (const hash of tokenizer.readHashes()) {\n      this.hash[hash.name.content] = hash.value\n    }\n  }\n  * render (ctx: Context) {\n    const hash = {}\n    for (const key of Object.keys(this.hash)) {\n      hash[key] = evalToken(this.hash[key], ctx)\n    }\n    return hash\n  }\n}\n","import { isFunction } from '../../util/underscore'\nimport { Liquid } from '../../liquid'\nimport { TemplateImpl } from '../../template/template-impl'\nimport { Emitter, Hash, Context, TagImplOptions, TagToken, Template, TopLevelToken } from '../../types'\nimport { TagImpl } from './tag-impl'\n\nexport class Tag extends TemplateImpl<TagToken> implements Template {\n  public name: string\n  private impl: TagImpl\n  private static impls: { [key: string]: TagImplOptions } = {}\n\n  public constructor (token: TagToken, tokens: TopLevelToken[], liquid: Liquid) {\n    super(token)\n    this.name = token.name\n\n    const impl = liquid.tags.get(token.name)\n\n    this.impl = Object.create(impl)\n    this.impl.liquid = liquid\n    if (this.impl.parse) {\n      this.impl.parse(token, tokens)\n    }\n  }\n  public * render (ctx: Context, emitter: Emitter) {\n    const hash = yield new Hash(this.token.args).render(ctx)\n    const impl = this.impl\n    if (isFunction(impl.render)) return yield impl.render(ctx, emitter, hash)\n  }\n}\n","import { evalToken } from '../../render/expression'\nimport { Context } from '../../context/context'\nimport { identify } from '../../util/underscore'\nimport { FilterImplOptions } from './filter-impl-options'\nimport { FilterArg, isKeyValuePair } from '../../parser/filter-arg'\n\nexport class Filter {\n  public name: string\n  public args: FilterArg[]\n  private impl: FilterImplOptions\n\n  public constructor (name: string, impl: FilterImplOptions, args: FilterArg[]) {\n    this.name = name\n    this.impl = impl || identify\n    this.args = args\n  }\n  public * render (value: any, context: Context) {\n    const argv: any[] = []\n    for (const arg of this.args as FilterArg[]) {\n      if (isKeyValuePair(arg)) argv.push([arg[0], yield evalToken(arg[1], context)])\n      else argv.push(yield evalToken(arg, context))\n    }\n    return this.impl.apply({ context }, [value, ...argv])\n  }\n}\n","import { isArray } from '../util/underscore'\nimport { ValueToken } from '../tokens/value-token'\n\ntype KeyValuePair = [string?, ValueToken?]\n\nexport type FilterArg = ValueToken | KeyValuePair\n\nexport function isKeyValuePair (arr: FilterArg): arr is KeyValuePair { // TODO check\n  return isArray(arr)\n}\n","import { evalToken } from '../render/expression'\nimport { Tokenizer } from '../parser/tokenizer'\nimport { FilterMap } from '../template/filter/filter-map'\nimport { Filter } from './filter/filter'\nimport { Context } from '../context/context'\nimport { ValueToken } from '../tokens/value-token'\n\nexport class Value {\n  public readonly filters: Filter[] = []\n  public readonly initial?: ValueToken\n\n  /**\n   * @param str the value to be valuated, eg.: \"foobar\" | truncate: 3\n   */\n  public constructor (str: string, private readonly filterMap: FilterMap) {\n    const tokenizer = new Tokenizer(str)\n    this.initial = tokenizer.readValue()\n    this.filters = tokenizer.readFilters().map(({ name, args }) => new Filter(name, this.filterMap.get(name), args))\n  }\n  public * value (ctx: Context) {\n    let val = yield evalToken(this.initial, ctx)\n    for (const filter of this.filters) {\n      val = yield filter.render(val, ctx)\n    }\n    return val\n  }\n}\n","import { Value } from './value'\nimport { FilterMap } from './filter/filter-map'\nimport { stringify, toValue } from '../util/underscore'\nimport { TemplateImpl } from '../template/template-impl'\nimport { Template } from '../template/template'\nimport { Context } from '../context/context'\nimport { Emitter } from '../render/emitter'\nimport { OutputToken } from '../tokens/output-token'\n\nexport class Output extends TemplateImpl<OutputToken> implements Template {\n  private value: Value\n  public constructor (token: OutputToken, filters: FilterMap) {\n    super(token)\n    this.value = new Value(token.content, filters)\n  }\n  public * render (ctx: Context, emitter: Emitter) {\n    const val = yield this.value.value(ctx)\n    emitter.write(stringify(toValue(val)))\n  }\n}\n","import { TemplateImpl } from '../template/template-impl'\nimport { Template } from '../template/template'\nimport { HTMLToken } from '../tokens/html-token'\nimport { Context } from '../context/context'\nimport { Emitter } from '../render/emitter'\n\nexport class HTML extends TemplateImpl<HTMLToken> implements Template {\n  private str: string\n  public constructor (token: HTMLToken) {\n    super(token)\n    this.str = token.getContent()\n  }\n  public * render (ctx: Context, emitter: Emitter): IterableIterator<void> {\n    emitter.write(this.str)\n  }\n}\n","import { ParseError } from '../util/error'\nimport { Liquid } from '../liquid'\nimport { ParseStream } from './parse-stream'\nimport { isTagToken, isOutputToken } from '../util/type-guards'\nimport { OutputToken } from '../tokens/output-token'\nimport { Tag } from '../template/tag/tag'\nimport { Output } from '../template/output'\nimport { HTML } from '../template/html'\nimport { Template } from '../template/template'\nimport { TopLevelToken } from '../tokens/toplevel-token'\n\nexport default class Parser {\n  private liquid: Liquid\n\n  public constructor (liquid: Liquid) {\n    this.liquid = liquid\n  }\n  public parse (tokens: TopLevelToken[]) {\n    let token\n    const templates: Template[] = []\n    while ((token = tokens.shift())) {\n      templates.push(this.parseToken(token, tokens))\n    }\n    return templates\n  }\n  public parseToken (token: TopLevelToken, remainTokens: TopLevelToken[]) {\n    try {\n      if (isTagToken(token)) {\n        return new Tag(token, remainTokens, this.liquid)\n      }\n      if (isOutputToken(token)) {\n        return new Output(token as OutputToken, this.liquid.filters)\n      }\n      return new HTML(token)\n    } catch (e) {\n      throw new ParseError(e, token)\n    }\n  }\n  public parseStream (tokens: TopLevelToken[]) {\n    return new ParseStream(tokens, (token, tokens) => this.parseToken(token, tokens))\n  }\n}\n","import { Tokenizer, assert, TagImplOptions, TagToken, Context } from '../../types'\n\nexport default {\n  parse: function (token: TagToken) {\n    const tokenizer = new Tokenizer(token.args)\n    this.key = tokenizer.readWord().content\n    tokenizer.skipBlank()\n    assert(tokenizer.peek() === '=', () => `illegal token ${token.getText()}`)\n    tokenizer.advance()\n    this.value = tokenizer.remaining()\n  },\n  render: function * (ctx: Context) {\n    ctx.bottom()[this.key] = yield this.liquid._evalValue(this.value, ctx)\n  }\n} as TagImplOptions\n","import { isString, isObject, isArray } from './underscore'\n\nexport function toEnumerable (val: any) {\n  if (isArray(val)) return val\n  if (isString(val) && val.length > 0) return [val]\n  if (isObject(val)) return Object.keys(val).map((key) => [key, val[key]])\n  return []\n}\n\nexport function toArray (val: any) {\n  if (isArray(val)) return val\n  return [ val ]\n}\n","import { Drop } from './drop'\n\nexport class ForloopDrop extends Drop {\n  protected i = 0\n  public length: number\n  public constructor (length: number) {\n    super()\n    this.length = length\n  }\n  public next () {\n    this.i++\n  }\n  public index0 () {\n    return this.i\n  }\n  public index () {\n    return this.i + 1\n  }\n  public first () {\n    return this.i === 0\n  }\n  public last () {\n    return this.i === this.length - 1\n  }\n  public rindex () {\n    return this.length - this.i\n  }\n  public rindex0 () {\n    return this.length - this.i - 1\n  }\n  public valueOf () {\n    return JSON.stringify(this)\n  }\n}\n","enum BlockMode {\n  /* store rendered html into blocks */\n  OUTPUT,\n  /* output rendered html directly */\n  STORE\n}\n\nexport default BlockMode\n","import { assert, Tokenizer, evalToken, Emitter, TagToken, TopLevelToken, Context, Template, TagImplOptions, ParseStream } from '../../types'\nimport { toEnumerable } from '../../util/collection'\nimport { ForloopDrop } from '../../drop/forloop-drop'\nimport { Hash } from '../../template/tag/hash'\n\nexport default {\n  type: 'block',\n  parse: function (token: TagToken, remainTokens: TopLevelToken[]) {\n    const toknenizer = new Tokenizer(token.args)\n\n    const variable = toknenizer.readWord()\n    const inStr = toknenizer.readWord()\n    const collection = toknenizer.readValue()\n    assert(\n      variable.size() && inStr.content === 'in' && collection,\n      () => `illegal tag: ${token.getText()}`\n    )\n\n    this.variable = variable.content\n    this.collection = collection\n    this.hash = new Hash(toknenizer.remaining())\n    this.templates = []\n    this.elseTemplates = []\n\n    let p\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => (p = this.templates))\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endfor', () => stream.stop())\n      .on('template', (tpl: Template) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${token.getText()} not closed`)\n      })\n\n    stream.start()\n  },\n  render: function * (ctx: Context, emitter: Emitter) {\n    const r = this.liquid.renderer\n    let collection = toEnumerable(evalToken(this.collection, ctx))\n\n    if (!collection.length) {\n      yield r.renderTemplates(this.elseTemplates, ctx, emitter)\n      return\n    }\n\n    const hash = yield this.hash.render(ctx)\n    const offset = hash.offset || 0\n    const limit = (hash.limit === undefined) ? collection.length : hash.limit\n\n    collection = collection.slice(offset, offset + limit)\n    if ('reversed' in hash) collection.reverse()\n\n    const scope = { forloop: new ForloopDrop(collection.length) }\n    ctx.push(scope)\n    for (const item of collection) {\n      scope[this.variable] = item\n      yield r.renderTemplates(this.templates, ctx, emitter)\n      if (emitter.break) {\n        emitter.break = false\n        break\n      }\n      emitter.continue = false\n      scope.forloop.next()\n    }\n    ctx.pop()\n  }\n} as TagImplOptions\n","import { Tokenizer, assert, Template, Context, TagImplOptions, TagToken, TopLevelToken } from '../../types'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    const tokenizer = new Tokenizer(tagToken.args)\n    this.variable = tokenizer.readWord().content\n    assert(this.variable, () => `${tagToken.args} not valid identifier`)\n\n    this.templates = []\n\n    const stream = this.liquid.parser.parseStream(remainTokens)\n    stream.on('tag:endcapture', () => stream.stop())\n      .on('template', (tpl: Template) => this.templates.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n    stream.start()\n  },\n  render: function * (ctx: Context) {\n    const r = this.liquid.renderer\n    const html = yield r.renderTemplates(this.templates, ctx)\n    ctx.bottom()[this.variable] = html\n  }\n} as TagImplOptions\n","import { Expression, Emitter, TagToken, TopLevelToken, Context, Template, TagImplOptions, ParseStream } from '../../types'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    this.cond = tagToken.args\n    this.cases = []\n    this.elseTemplates = []\n\n    let p: Template[] = []\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('tag:when', (token: TagToken) => {\n        this.cases.push({\n          val: token.args,\n          templates: p = []\n        })\n      })\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endcase', () => stream.stop())\n      .on('template', (tpl: Template) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n\n    stream.start()\n  },\n\n  render: function * (ctx: Context, emitter: Emitter) {\n    const r = this.liquid.renderer\n    const cond = yield new Expression(this.cond).value(ctx)\n    for (let i = 0; i < this.cases.length; i++) {\n      const branch = this.cases[i]\n      const val = yield new Expression(branch.val).value(ctx)\n      if (val === cond) {\n        yield r.renderTemplates(branch.templates, ctx, emitter)\n        return\n      }\n    }\n    yield r.renderTemplates(this.elseTemplates, ctx, emitter)\n  }\n} as TagImplOptions\n","import { TagToken } from '../../tokens/tag-token'\nimport { TopLevelToken } from '../../tokens/toplevel-token'\nimport { TagImplOptions } from '../../template/tag/tag-impl-options'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    const stream = this.liquid.parser.parseStream(remainTokens)\n    stream\n      .on('token', (token: TagToken) => {\n        if (token.name === 'endcomment') stream.stop()\n      })\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n    stream.start()\n  }\n} as TagImplOptions\n","import { assert, evalQuotedToken, TypeGuards, Tokenizer, evalToken, Hash, Emitter, TagToken, Context, TagImplOptions } from '../../types'\nimport BlockMode from '../../context/block-mode'\n\nexport default {\n  parse: function (token: TagToken) {\n    const args = token.args\n    const tokenizer = new Tokenizer(args)\n    this.file = this.liquid.options.dynamicPartials\n      ? tokenizer.readValue()\n      : tokenizer.readFileName()\n    assert(this.file, () => `illegal argument \"${token.args}\"`)\n\n    const begin = tokenizer.p\n    const withStr = tokenizer.readWord()\n    if (withStr.content === 'with') {\n      tokenizer.skipBlank()\n      if (tokenizer.peek() !== ':') {\n        this.withVar = tokenizer.readValue()\n      } else tokenizer.p = begin\n    } else tokenizer.p = begin\n\n    this.hash = new Hash(tokenizer.remaining())\n  },\n  render: function * (ctx: Context, emitter: Emitter) {\n    const { liquid, hash, withVar, file } = this\n    const { renderer } = liquid\n    const filepath = ctx.opts.dynamicPartials\n      ? (TypeGuards.isQuotedToken(file)\n        ? yield renderer.renderTemplates(liquid.parse(evalQuotedToken(file)), ctx)\n        : yield evalToken(file, ctx))\n      : file.getText()\n    assert(filepath, () => `illegal filename \"${file.getText()}\":\"${filepath}\"`)\n\n    const saved = ctx.saveRegister('blocks', 'blockMode')\n    ctx.setRegister('blocks', {})\n    ctx.setRegister('blockMode', BlockMode.OUTPUT)\n    const scope = yield hash.render(ctx)\n    if (withVar) scope[filepath] = evalToken(withVar, ctx)\n    const templates = yield liquid._parseFile(filepath, ctx.opts, ctx.sync)\n    ctx.push(scope)\n    yield renderer.renderTemplates(templates, ctx, emitter)\n    ctx.pop()\n    ctx.restoreRegister(saved)\n  }\n} as TagImplOptions\n","import { assert } from '../../util/assert'\nimport { ForloopDrop } from '../../drop/forloop-drop'\nimport { toEnumerable } from '../../util/collection'\nimport { evalQuotedToken, TypeGuards, Tokenizer, evalToken, Hash, Emitter, TagToken, Context, TagImplOptions } from '../../types'\n\nexport default {\n  parse: function (token: TagToken) {\n    const args = token.args\n    const tokenizer = new Tokenizer(args)\n    this.file = this.liquid.options.dynamicPartials\n      ? tokenizer.readValue()\n      : tokenizer.readFileName()\n    assert(this.file, () => `illegal argument \"${token.args}\"`)\n\n    while (!tokenizer.end()) {\n      tokenizer.skipBlank()\n      const begin = tokenizer.p\n      const keyword = tokenizer.readWord()\n      if (keyword.content === 'with' || keyword.content === 'for') {\n        tokenizer.skipBlank()\n        if (tokenizer.peek() !== ':') {\n          const value = tokenizer.readValue()\n          if (value) {\n            const beforeAs = tokenizer.p\n            const asStr = tokenizer.readWord()\n            let alias\n            if (asStr.content === 'as') alias = tokenizer.readWord()\n            else tokenizer.p = beforeAs\n\n            this[keyword.content] = { value, alias: alias && alias.content }\n            tokenizer.skipBlank()\n            if (tokenizer.peek() === ',') tokenizer.advance()\n            continue\n          }\n        }\n      }\n      tokenizer.p = begin\n      break\n    }\n    this.hash = new Hash(tokenizer.remaining())\n  },\n  render: function * (ctx: Context, emitter: Emitter) {\n    const { liquid, file, hash } = this\n    const { renderer } = liquid\n    const filepath = ctx.opts.dynamicPartials\n      ? (TypeGuards.isQuotedToken(file)\n        ? yield renderer.renderTemplates(liquid.parse(evalQuotedToken(file)), ctx)\n        : evalToken(file, ctx))\n      : file.getText()\n    assert(filepath, () => `illegal filename \"${file.getText()}\":\"${filepath}\"`)\n\n    const childCtx = new Context({}, ctx.opts, ctx.sync)\n    const scope = yield hash.render(ctx)\n    if (this['with']) {\n      const { value, alias } = this['with']\n      scope[alias || filepath] = evalToken(value, ctx)\n    }\n    childCtx.push(scope)\n\n    if (this['for']) {\n      const { value, alias } = this['for']\n      let collection = evalToken(value, ctx)\n      collection = toEnumerable(collection)\n      scope['forloop'] = new ForloopDrop(collection.length)\n      for (const item of collection) {\n        scope[alias] = item\n        const templates = yield liquid._parseFile(filepath, childCtx.opts, childCtx.sync)\n        yield renderer.renderTemplates(templates, childCtx, emitter)\n        scope.forloop.next()\n      }\n    } else {\n      const templates = yield liquid._parseFile(filepath, childCtx.opts, childCtx.sync)\n      yield renderer.renderTemplates(templates, childCtx, emitter)\n    }\n  }\n} as TagImplOptions\n","import { Tokenizer, Emitter, TagToken, Context, TagImplOptions } from '../../types'\nimport { isNumber, stringify } from '../../util/underscore'\n\nexport default {\n  parse: function (token: TagToken) {\n    const tokenizer = new Tokenizer(token.args)\n    this.variable = tokenizer.readWord().content\n  },\n  render: function (context: Context, emitter: Emitter) {\n    const scope = context.environments\n    if (!isNumber(scope[this.variable])) {\n      scope[this.variable] = 0\n    }\n    emitter.write(stringify(--scope[this.variable]))\n  }\n} as TagImplOptions\n","import { assert } from '../../util/assert'\nimport { evalToken, Emitter, TagToken, Context, TagImplOptions } from '../../types'\nimport { Tokenizer } from '../../parser/tokenizer'\n\nexport default {\n  parse: function (tagToken: TagToken) {\n    const tokenizer = new Tokenizer(tagToken.args)\n    const group = tokenizer.readValue()\n    tokenizer.skipBlank()\n\n    this.candidates = []\n\n    if (group) {\n      if (tokenizer.peek() === ':') {\n        this.group = group\n        tokenizer.advance()\n      } else this.candidates.push(group)\n    }\n\n    while (!tokenizer.end()) {\n      const value = tokenizer.readValue()\n      if (value) this.candidates.push(value)\n      tokenizer.readTo(',')\n    }\n    assert(this.candidates.length, () => `empty candidates: ${tagToken.getText()}`)\n  },\n\n  render: function (ctx: Context, emitter: Emitter) {\n    const group = evalToken(this.group, ctx)\n    const fingerprint = `cycle:${group}:` + this.candidates.join(',')\n    const groups = ctx.getRegister('cycle')\n    let idx = groups[fingerprint]\n\n    if (idx === undefined) {\n      idx = groups[fingerprint] = 0\n    }\n\n    const candidate = this.candidates[idx]\n    idx = (idx + 1) % this.candidates.length\n    groups[fingerprint] = idx\n    const html = evalToken(candidate, ctx)\n    emitter.write(html)\n  }\n} as TagImplOptions\n","import { Emitter, isTruthy, Expression, TagToken, TopLevelToken, Context, Template, TagImplOptions, ParseStream } from '../../types'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    this.branches = []\n    this.elseTemplates = []\n\n    let p\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => this.branches.push({\n        cond: tagToken.args,\n        templates: (p = [])\n      }))\n      .on('tag:elsif', (token: TagToken) => {\n        this.branches.push({\n          cond: token.args,\n          templates: p = []\n        })\n      })\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endif', () => stream.stop())\n      .on('template', (tpl: Template) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n\n    stream.start()\n  },\n\n  render: function * (ctx: Context, emitter: Emitter) {\n    const r = this.liquid.renderer\n\n    for (const branch of this.branches) {\n      const cond = yield new Expression(branch.cond).value(ctx)\n      if (isTruthy(cond)) {\n        yield r.renderTemplates(branch.templates, ctx, emitter)\n        return\n      }\n    }\n    yield r.renderTemplates(this.elseTemplates, ctx, emitter)\n  }\n} as TagImplOptions\n","import { isNumber, stringify } from '../../util/underscore'\nimport { Tokenizer, Emitter, TagToken, Context, TagImplOptions } from '../../types'\n\nexport default {\n  parse: function (token: TagToken) {\n    const tokenizer = new Tokenizer(token.args)\n    this.variable = tokenizer.readWord().content\n  },\n  render: function (context: Context, emitter: Emitter) {\n    const scope = context.environments\n    if (!isNumber(scope[this.variable])) {\n      scope[this.variable] = 0\n    }\n    const val = scope[this.variable]\n    scope[this.variable]++\n    emitter.write(stringify(val))\n  }\n} as TagImplOptions\n","import { assert, evalQuotedToken, TypeGuards, evalToken, Tokenizer, Emitter, Hash, TagToken, TopLevelToken, Context, TagImplOptions } from '../../types'\nimport BlockMode from '../../context/block-mode'\n\nexport default {\n  parse: function (token: TagToken, remainTokens: TopLevelToken[]) {\n    const tokenizer = new Tokenizer(token.args)\n    const file = this.liquid.options.dynamicPartials ? tokenizer.readValue() : tokenizer.readFileName()\n    assert(file, () => `illegal argument \"${token.args}\"`)\n\n    this.file = file\n    this.hash = new Hash(tokenizer.remaining())\n    this.tpls = this.liquid.parser.parse(remainTokens)\n  },\n  render: function * (ctx: Context, emitter: Emitter) {\n    const { liquid, hash, file } = this\n    const { renderer } = liquid\n    const filepath = ctx.opts.dynamicPartials\n      ? (TypeGuards.isQuotedToken(file)\n        ? yield renderer.renderTemplates(liquid.parse(evalQuotedToken(file)), ctx)\n        : evalToken(this.file, ctx))\n      : file.getText()\n    assert(filepath, () => `illegal filename \"${file.getText()}\":\"${filepath}\"`)\n\n    // render the remaining tokens immediately\n    ctx.setRegister('blockMode', BlockMode.STORE)\n    const blocks = ctx.getRegister('blocks')\n    const html = yield renderer.renderTemplates(this.tpls, ctx)\n    if (blocks[''] === undefined) blocks[''] = html\n    const templates = yield liquid._parseFile(filepath, ctx.opts, ctx.sync)\n    ctx.push(yield hash.render(ctx))\n    ctx.setRegister('blockMode', BlockMode.OUTPUT)\n    const partial = yield renderer.renderTemplates(templates, ctx)\n    ctx.pop()\n    emitter.write(partial)\n  }\n} as TagImplOptions\n","import BlockMode from '../../context/block-mode'\nimport { ParseStream, TagToken, TopLevelToken, Template, Context, TagImplOptions, Emitter } from '../../types'\n\nexport default {\n  parse: function (token: TagToken, remainTokens: TopLevelToken[]) {\n    const match = /\\w+/.exec(token.args)\n    this.block = match ? match[0] : ''\n    this.tpls = [] as Template[]\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('tag:endblock', () => stream.stop())\n      .on('template', (tpl: Template) => this.tpls.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${token.getText()} not closed`)\n      })\n    stream.start()\n  },\n  render: function * (ctx: Context, emitter: Emitter) {\n    const blocks = ctx.getRegister('blocks')\n    const childDefined = blocks[this.block]\n    const r = this.liquid.renderer\n    const html = childDefined !== undefined\n      ? childDefined\n      : yield r.renderTemplates(this.tpls, ctx)\n\n    if (ctx.getRegister('blockMode', BlockMode.OUTPUT) === BlockMode.STORE) {\n      blocks[this.block] = html\n      return\n    }\n    emitter.write(html)\n  }\n} as TagImplOptions\n","import { TagToken, TopLevelToken, TagImplOptions } from '../../types'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    this.tokens = []\n\n    const stream = this.liquid.parser.parseStream(remainTokens)\n    stream\n      .on('token', (token: TagToken) => {\n        if (token.name === 'endraw') stream.stop()\n        else this.tokens.push(token)\n      })\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n    stream.start()\n  },\n  render: function () {\n    return this.tokens.map((token: TopLevelToken) => token.getText()).join('')\n  }\n} as TagImplOptions\n","import { ForloopDrop } from './forloop-drop'\n\nexport class TablerowloopDrop extends ForloopDrop {\n  private cols: number\n  public constructor (length: number, cols: number) {\n    super(length)\n    this.length = length\n    this.cols = cols\n  }\n  public row () {\n    return Math.floor(this.i / this.cols) + 1\n  }\n  public col0 () {\n    return (this.i % this.cols)\n  }\n  public col () {\n    return this.col0() + 1\n  }\n  public col_first () {  // eslint-disable-line\n    return this.col0() === 0\n  }\n  public col_last () { // eslint-disable-line\n    return this.col() === this.cols\n  }\n}\n","import assign from './assign'\nimport For from './for'\nimport capture from './capture'\nimport Case from './case'\nimport comment from './comment'\nimport include from './include'\nimport render from './render'\nimport decrement from './decrement'\nimport cycle from './cycle'\nimport If from './if'\nimport increment from './increment'\nimport layout from './layout'\nimport block from './block'\nimport raw from './raw'\nimport tablerow from './tablerow'\nimport unless from './unless'\nimport Break from './break'\nimport Continue from './continue'\nimport { TagImplOptions } from '../../template/tag/tag-impl-options'\n\nconst tags: { [key: string]: TagImplOptions } = {\n  assign, 'for': For, capture, 'case': Case, comment, include, render, decrement, increment, cycle, 'if': If, layout, block, raw, tablerow, unless, 'break': Break, 'continue': Continue\n}\n\nexport default tags\n","import { toEnumerable } from '../../util/collection'\nimport { assert, evalToken, Emitter, Hash, TagToken, TopLevelToken, Context, Template, TagImplOptions, ParseStream } from '../../types'\nimport { TablerowloopDrop } from '../../drop/tablerowloop-drop'\nimport { Tokenizer } from '../../parser/tokenizer'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    const tokenizer = new Tokenizer(tagToken.args)\n\n    this.variable = tokenizer.readWord()\n    tokenizer.skipBlank()\n\n    const tmp = tokenizer.readWord()\n    assert(tmp && tmp.content === 'in', () => `illegal tag: ${tagToken.getText()}`)\n\n    this.collection = tokenizer.readValue()\n    this.hash = new Hash(tokenizer.remaining())\n    this.templates = []\n\n    let p\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => (p = this.templates))\n      .on('tag:endtablerow', () => stream.stop())\n      .on('template', (tpl: Template) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n\n    stream.start()\n  },\n\n  render: function * (ctx: Context, emitter: Emitter) {\n    let collection = toEnumerable(evalToken(this.collection, ctx))\n    const hash = yield this.hash.render(ctx)\n    const offset = hash.offset || 0\n    const limit = (hash.limit === undefined) ? collection.length : hash.limit\n\n    collection = collection.slice(offset, offset + limit)\n    const cols = hash.cols || collection.length\n\n    const r = this.liquid.renderer\n    const tablerowloop = new TablerowloopDrop(collection.length, cols)\n    const scope = { tablerowloop }\n    ctx.push(scope)\n\n    for (let idx = 0; idx < collection.length; idx++, tablerowloop.next()) {\n      scope[this.variable.content] = collection[idx]\n      if (tablerowloop.col0() === 0) {\n        if (tablerowloop.row() !== 1) emitter.write('</tr>')\n        emitter.write(`<tr class=\"row${tablerowloop.row()}\">`)\n      }\n      emitter.write(`<td class=\"col${tablerowloop.col()}\">`)\n      yield r.renderTemplates(this.templates, ctx, emitter)\n      emitter.write('</td>')\n    }\n    if (collection.length) emitter.write('</tr>')\n    ctx.pop()\n  }\n} as TagImplOptions\n","import { TopLevelToken, Template, Emitter, Expression, isFalsy, ParseStream, Context, TagImplOptions, Token, TagToken } from '../../types'\n\nexport default {\n  parse: function (tagToken: TagToken, remainTokens: TopLevelToken[]) {\n    this.templates = []\n    this.elseTemplates = []\n    let p\n    const stream: ParseStream = this.liquid.parser.parseStream(remainTokens)\n      .on('start', () => {\n        p = this.templates\n        this.cond = tagToken.args\n      })\n      .on('tag:else', () => (p = this.elseTemplates))\n      .on('tag:endunless', () => stream.stop())\n      .on('template', (tpl: Template) => p.push(tpl))\n      .on('end', () => {\n        throw new Error(`tag ${tagToken.getText()} not closed`)\n      })\n\n    stream.start()\n  },\n\n  render: function * (ctx: Context, emitter: Emitter) {\n    const r = this.liquid.renderer\n    const cond = yield new Expression(this.cond).value(ctx)\n    yield (isFalsy(cond)\n      ? r.renderTemplates(this.templates, ctx, emitter)\n      : r.renderTemplates(this.elseTemplates, ctx, emitter))\n  }\n} as TagImplOptions\n","import { Emitter, Context } from '../../types'\n\nexport default {\n  render: function (ctx: Context, emitter: Emitter) {\n    emitter.break = true\n  }\n}\n","import { Emitter, Context } from '../../types'\n\nexport default {\n  render: function (ctx: Context, emitter: Emitter) {\n    emitter.continue = true\n  }\n}\n","import { stringify } from '../../util/underscore'\n\nconst escapeMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&#34;',\n  \"'\": '&#39;'\n}\nconst unescapeMap = {\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>',\n  '&#34;': '\"',\n  '&#39;': \"'\"\n}\n\nexport function escape (str: string) {\n  return stringify(str).replace(/&|<|>|\"|'/g, m => escapeMap[m])\n}\n\nfunction unescape (str: string) {\n  return String(str).replace(/&(amp|lt|gt|#34|#39);/g, m => unescapeMap[m])\n}\n\nexport function escapeOnce (str: string) {\n  return escape(unescape(str))\n}\n\nexport function newlineToBr (v: string) {\n  return v.replace(/\\n/g, '<br/>')\n}\n\nexport function stripHtml (v: string) {\n  return v.replace(/<script.*?<\\/script>|<!--.*?-->|<style.*?<\\/style>|<.*?>/g, '')\n}\n","import { caseInsensitiveCompare } from '../../util/underscore'\n\nexport const abs = Math.abs\nexport const atLeast = Math.max\nexport const atMost = Math.min\nexport const ceil = Math.ceil\nexport const dividedBy = (v: number, arg: number) => v / arg\nexport const floor = Math.floor\nexport const minus = (v: number, arg: number) => v - arg\nexport const modulo = (v: number, arg: number) => v % arg\nexport const times = (v: number, arg: number) => v * arg\n\nexport function round (v: number, arg = 0) {\n  const amp = Math.pow(10, arg)\n  return Math.round(v * amp) / amp\n}\n\nexport function plus (v: number, arg: number) {\n  return Number(v) + Number(arg)\n}\n\nexport function sortNatural (input: any[], property?: string) {\n  if (!input || !input.sort) return []\n  if (property !== undefined) {\n    return [...input].sort(\n      (lhs, rhs) => caseInsensitiveCompare(lhs[property], rhs[property])\n    )\n  }\n  return [...input].sort(caseInsensitiveCompare)\n}\n","import { changeCase, padStart, padEnd } from './underscore'\n\nconst rFormat = /%([-_0^#:]+)?(\\d+)?([EO])?(.)/\nconst monthNames = [\n  'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',\n  'September', 'October', 'November', 'December'\n]\nconst dayNames = [\n  'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'\n]\nconst monthNamesShort = monthNames.map(abbr)\nconst dayNamesShort = dayNames.map(abbr)\nconst suffixes = {\n  1: 'st',\n  2: 'nd',\n  3: 'rd',\n  'default': 'th'\n}\ninterface FormatOptions {\n  flags: object;\n  width?: string;\n  modifier?: string;\n}\n\nfunction abbr (str: string) {\n  return str.slice(0, 3)\n}\n\n// prototype extensions\nfunction daysInMonth (d: Date) {\n  const feb = isLeapYear(d) ? 29 : 28\n  return [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n}\nfunction getDayOfYear (d: Date) {\n  let num = 0\n  for (let i = 0; i < d.getMonth(); ++i) {\n    num += daysInMonth(d)[i]\n  }\n  return num + d.getDate()\n}\nfunction getWeekOfYear (d: Date, startDay: number) {\n  // Skip to startDay of this week\n  const now = getDayOfYear(d) + (startDay - d.getDay())\n  // Find the first startDay of the year\n  const jan1 = new Date(d.getFullYear(), 0, 1)\n  const then = (7 - jan1.getDay() + startDay)\n  return String(Math.floor((now - then) / 7) + 1)\n}\nfunction isLeapYear (d: Date) {\n  const year = d.getFullYear()\n  return !!((year & 3) === 0 && (year % 100 || (year % 400 === 0 && year)))\n}\nfunction getSuffix (d: Date) {\n  const str = d.getDate().toString()\n  const index = parseInt(str.slice(-1))\n  return suffixes[index] || suffixes['default']\n}\nfunction century (d: Date) {\n  return parseInt(d.getFullYear().toString().substring(0, 2), 10)\n}\n\n// default to 0\nconst padWidths = {\n  d: 2,\n  e: 2,\n  H: 2,\n  I: 2,\n  j: 3,\n  k: 2,\n  l: 2,\n  L: 3,\n  m: 2,\n  M: 2,\n  S: 2,\n  U: 2,\n  W: 2\n}\n\n// default to '0'\nconst padChars = {\n  a: ' ',\n  A: ' ',\n  b: ' ',\n  B: ' ',\n  c: ' ',\n  e: ' ',\n  k: ' ',\n  l: ' ',\n  p: ' ',\n  P: ' '\n}\nconst formatCodes = {\n  a: (d: Date) => dayNamesShort[d.getDay()],\n  A: (d: Date) => dayNames[d.getDay()],\n  b: (d: Date) => monthNamesShort[d.getMonth()],\n  B: (d: Date) => monthNames[d.getMonth()],\n  c: (d: Date) => d.toLocaleString(),\n  C: (d: Date) => century(d),\n  d: (d: Date) => d.getDate(),\n  e: (d: Date) => d.getDate(),\n  H: (d: Date) => d.getHours(),\n  I: (d: Date) => String(d.getHours() % 12 || 12),\n  j: (d: Date) => getDayOfYear(d),\n  k: (d: Date) => d.getHours(),\n  l: (d: Date) => String(d.getHours() % 12 || 12),\n  L: (d: Date) => d.getMilliseconds(),\n  m: (d: Date) => d.getMonth() + 1,\n  M: (d: Date) => d.getMinutes(),\n  N: (d: Date, opts: FormatOptions) => {\n    const width = Number(opts.width) || 9\n    const str = String(d.getMilliseconds()).substr(0, width)\n    return padEnd(str, width, '0')\n  },\n  p: (d: Date) => (d.getHours() < 12 ? 'AM' : 'PM'),\n  P: (d: Date) => (d.getHours() < 12 ? 'am' : 'pm'),\n  q: (d: Date) => getSuffix(d),\n  s: (d: Date) => Math.round(d.valueOf() / 1000),\n  S: (d: Date) => d.getSeconds(),\n  u: (d: Date) => d.getDay() || 7,\n  U: (d: Date) => getWeekOfYear(d, 0),\n  w: (d: Date) => d.getDay(),\n  W: (d: Date) => getWeekOfYear(d, 1),\n  x: (d: Date) => d.toLocaleDateString(),\n  X: (d: Date) => d.toLocaleTimeString(),\n  y: (d: Date) => d.getFullYear().toString().substring(2, 4),\n  Y: (d: Date) => d.getFullYear(),\n  z: (d: Date, opts: FormatOptions) => {\n    const offset = d.getTimezoneOffset()\n    const nOffset = Math.abs(offset)\n    const h = Math.floor(nOffset / 60)\n    const m = nOffset % 60\n    return (offset > 0 ? '-' : '+') +\n      padStart(h, 2, '0') +\n      (opts.flags[':'] ? ':' : '') +\n      padStart(m, 2, '0')\n  },\n  't': () => '\\t',\n  'n': () => '\\n',\n  '%': () => '%'\n};\n(formatCodes as any).h = formatCodes.b\n\nexport default function (d: Date, formatStr: string) {\n  let output = ''\n  let remaining = formatStr\n  let match\n  while ((match = rFormat.exec(remaining))) {\n    output += remaining.slice(0, match.index)\n    remaining = remaining.slice(match.index + match[0].length)\n    output += format(d, match)\n  }\n  return output + remaining\n}\n\nfunction format (d: Date, match: RegExpExecArray) {\n  const [input, flagStr = '', width, modifier, conversion] = match\n  const convert = formatCodes[conversion]\n  if (!convert) return input\n  const flags = {}\n  for (const flag of flagStr) flags[flag] = true\n  let ret = String(convert(d, { flags, width, modifier }))\n  let padChar = padChars[conversion] || '0'\n  let padWidth = width || padWidths[conversion] || 0\n  if (flags['^']) ret = ret.toUpperCase()\n  else if (flags['#']) ret = changeCase(ret)\n  if (flags['_']) padChar = ' '\n  else if (flags['0']) padChar = '0'\n  if (flags['-']) padWidth = 0\n  return padStart(ret, padWidth, padChar)\n}\n","export const urlDecode = (x: string) => x.split('+').map(decodeURIComponent).join(' ')\nexport const urlEncode = (x: string) => x.split(' ').map(encodeURIComponent).join('+')\n","import { isArray, last as arrayLast } from '../../util/underscore'\nimport { toArray } from '../../util/collection'\nimport { isTruthy } from '../../render/boolean'\nimport { FilterImpl } from '../../template/filter/filter-impl'\n\nexport const join = (v: any[], arg: string) => v.join(arg === undefined ? ' ' : arg)\nexport const last = (v: any) => isArray(v) ? arrayLast(v) : ''\nexport const first = (v: any) => isArray(v) ? v[0] : ''\nexport const reverse = (v: any[]) => [...v].reverse()\nexport const sort = <T>(v: T[], arg: (lhs: T, rhs: T) => number) => v.sort(arg)\nexport const size = (v: string | any[]) => (v && v.length) || 0\n\nexport function map<T1, T2> (arr: {[key: string]: T1}[], arg: string): T1[] {\n  return toArray(arr).map(v => v[arg])\n}\n\nexport function concat<T1, T2> (v: T1[], arg: T2[] | T2): (T1 | T2)[] {\n  return toArray(v).concat(arg)\n}\n\nexport function slice<T> (v: T[], begin: number, length = 1): T[] {\n  begin = begin < 0 ? v.length + begin : begin\n  return v.slice(begin, begin + length)\n}\n\nexport function where<T extends object> (this: FilterImpl, arr: T[], property: string, expected?: any): T[] {\n  return toArray(arr).filter(obj => {\n    const value = this.context.getFromScope(obj, String(property).split('.'))\n    return expected === undefined ? isTruthy(value) : value === expected\n  })\n}\n\nexport function uniq<T> (arr: T[]): T[] {\n  const u = {}\n  return (arr || []).filter(val => {\n    if (u.hasOwnProperty(String(val))) return false\n    u[String(val)] = true\n    return true\n  })\n}\n","import strftime from '../../util/strftime'\nimport { isString, isNumber } from '../../util/underscore'\n\nexport function date (v: string | Date, arg: string) {\n  let date = v\n  if (v === 'now' || v === 'today') {\n    date = new Date()\n  } else if (isNumber(v)) {\n    date = new Date(v * 1000)\n  } else if (isString(v)) {\n    date = /^\\d+$/.test(v) ? new Date(+v * 1000) : new Date(v)\n  }\n  return isValidDate(date) ? strftime(date, arg) : v\n}\n\nfunction isValidDate (date: any): date is Date {\n  return date instanceof Date && !isNaN(date.getTime())\n}\n","import { isFalsy } from '../../render/boolean'\nimport { isArray, isString, toValue } from '../../util/underscore'\n\nexport function Default<T1, T2> (v: string | T1, arg: T2): string | T1 | T2 {\n  if (isArray(v) || isString(v)) return v.length ? v : arg\n  return isFalsy(toValue(v)) ? arg : v\n}\nexport function json (v: any) {\n  return JSON.stringify(v)\n}\n","/**\n * String related filters\n *\n * * prefer stringify() to String() since `undefined`, `null` should eval ''\n */\nimport { stringify } from '../../util/underscore'\nimport { assert } from '../../util/assert'\n\nexport function append (v: string, arg: string) {\n  assert(arg !== undefined, () => 'append expect 2 arguments')\n  return stringify(v) + stringify(arg)\n}\n\nexport function prepend (v: string, arg: string) {\n  assert(arg !== undefined, () => 'prepend expect 2 arguments')\n  return stringify(arg) + stringify(v)\n}\n\nexport function lstrip (v: string) {\n  return stringify(v).replace(/^\\s+/, '')\n}\n\nexport function downcase (v: string) {\n  return stringify(v).toLowerCase()\n}\n\nexport function upcase (str: string) {\n  return stringify(str).toUpperCase()\n}\n\nexport function remove (v: string, arg: string) {\n  return stringify(v).split(arg).join('')\n}\n\nexport function removeFirst (v: string, l: string) {\n  return stringify(v).replace(l, '')\n}\n\nexport function rstrip (str: string) {\n  return stringify(str).replace(/\\s+$/, '')\n}\n\nexport function split (v: string, arg: string) {\n  return stringify(v).split(arg)\n}\n\nexport function strip (v: string) {\n  return stringify(v).trim()\n}\n\nexport function stripNewlines (v: string) {\n  return stringify(v).replace(/\\n/g, '')\n}\n\nexport function capitalize (str: string) {\n  str = stringify(str)\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nexport function replace (v: string, pattern: string, replacement: string) {\n  return stringify(v).split(pattern).join(replacement)\n}\n\nexport function replaceFirst (v: string, arg1: string, arg2: string) {\n  return stringify(v).replace(arg1, arg2)\n}\n\nexport function truncate (v: string, l = 50, o = '...') {\n  v = stringify(v)\n  if (v.length <= l) return v\n  return v.substr(0, l - o.length) + o\n}\n\nexport function truncatewords (v: string, l = 15, o = '...') {\n  const arr = v.split(/\\s+/)\n  let ret = arr.slice(0, l).join(' ')\n  if (arr.length >= l) ret += o\n  return ret\n}\n","import { TagImplOptions } from './tag-impl-options'\nimport { assert } from '../../util/assert'\n\nexport class TagMap {\n  private impls: {[key: string]: TagImplOptions} = {}\n\n  get (name: string) {\n    const impl = this.impls[name]\n    assert(impl, () => `tag \"${name}\" not found`)\n    return impl\n  }\n\n  set (name: string, impl: TagImplOptions) {\n    this.impls[name] = impl\n  }\n}\n","import { FilterImplOptions } from './filter-impl-options'\nimport { Filter } from './filter'\nimport { FilterArg } from '../../parser/filter-arg'\nimport { assert } from '../../util/assert'\n\nexport class FilterMap {\n  private impls: {[key: string]: FilterImplOptions} = {}\n\n  constructor (private readonly strictFilters: boolean) {}\n\n  get (name: string) {\n    const impl = this.impls[name]\n    assert(impl || !this.strictFilters, () => `undefined filter: ${name}`)\n    return impl\n  }\n\n  set (name: string, impl: FilterImplOptions) {\n    this.impls[name] = impl\n  }\n\n  create (name: string, args: FilterArg[]) {\n    return new Filter(name, this.get(name), args)\n  }\n}\n","import { isFunction } from './underscore'\n\ntype resolver = (x?: any) => any\n\ninterface Thenable {\n  then (resolve: resolver, reject?: resolver): Thenable;\n  catch (reject: resolver): Thenable;\n}\n\nfunction mkResolve (value: any) {\n  const ret = {\n    then: (resolve: resolver) => resolve(value),\n    catch: () => ret\n  }\n  return ret\n}\n\nfunction mkReject (err: Error) {\n  const ret = {\n    then: (resolve: resolver, reject?: resolver) => {\n      if (reject) return reject(err)\n      return ret\n    },\n    catch: (reject: resolver) => reject(err)\n  }\n  return ret\n}\n\nfunction isThenable (val: any): val is Thenable {\n  return val && isFunction(val.then)\n}\n\nfunction isCustomIterable (val: any): val is IterableIterator<any> {\n  return val && isFunction(val.next) && isFunction(val.throw) && isFunction(val.return)\n}\n\nexport function toThenable (val: IterableIterator<any> | Thenable | any): Thenable {\n  if (isThenable(val)) return val\n  if (isCustomIterable(val)) return reduce()\n  return mkResolve(val)\n\n  function reduce (prev?: any): Thenable {\n    let state\n    try {\n      state = (val as IterableIterator<any>).next(prev)\n    } catch (err) {\n      return mkReject(err)\n    }\n\n    if (state.done) return mkResolve(state.value)\n    return toThenable(state.value!).then(reduce, err => {\n      let state\n      try {\n        state = (val as IterableIterator<any>).throw!(err)\n      } catch (e) {\n        return mkReject(e)\n      }\n      if (state.done) return mkResolve(state.value)\n      return reduce(state.value)\n    })\n  }\n}\n\nexport function toValue (val: IterableIterator<any> | Thenable | any) {\n  let ret: any\n  toThenable(val)\n    .then((x: any) => {\n      ret = x\n      return mkResolve(ret)\n    })\n    .catch((err: Error) => {\n      throw err\n    })\n  return ret\n}\n","import { Context } from './context/context'\nimport * as fs from './fs/node'\nimport { forOwn, snakeCase } from './util/underscore'\nimport { Template } from './template/template'\nimport { Tokenizer } from './parser/tokenizer'\nimport { Render } from './render/render'\nimport Parser from './parser/parser'\nimport { TagImplOptions } from './template/tag/tag-impl-options'\nimport { Value } from './template/value'\nimport builtinTags from './builtin/tags'\nimport * as builtinFilters from './builtin/filters'\nimport { TagMap } from './template/tag/tag-map'\nimport { FilterMap } from './template/filter/filter-map'\nimport { LiquidOptions, normalizeStringArray, NormalizedFullOptions, applyDefault, normalize } from './liquid-options'\nimport { FilterImplOptions } from './template/filter/filter-impl-options'\nimport { FS } from './fs/fs'\nimport { toThenable, toValue } from './util/async'\n\nexport * from './types'\n\nexport class Liquid {\n  public options: NormalizedFullOptions\n  public renderer: Render\n  public parser: Parser\n  public filters: FilterMap\n  public tags: TagMap\n  private fs: FS\n\n  public constructor (opts: LiquidOptions = {}) {\n    this.options = applyDefault(normalize(opts))\n    this.parser = new Parser(this)\n    this.renderer = new Render()\n    this.fs = opts.fs || fs\n    this.filters = new FilterMap(this.options.strictFilters)\n    this.tags = new TagMap()\n\n    forOwn(builtinTags, (conf: TagImplOptions, name: string) => this.registerTag(snakeCase(name), conf))\n    forOwn(builtinFilters, (handler: FilterImplOptions, name: string) => this.registerFilter(snakeCase(name), handler))\n  }\n  public parse (html: string, filepath?: string): Template[] {\n    const tokenizer = new Tokenizer(html, filepath)\n    const tokens = tokenizer.readTopLevelTokens(this.options)\n    return this.parser.parse(tokens)\n  }\n\n  public _render (tpl: Template[], scope?: object, opts?: LiquidOptions, sync?: boolean): IterableIterator<string> {\n    const options = { ...this.options, ...normalize(opts) }\n    const ctx = new Context(scope, options, sync)\n    return this.renderer.renderTemplates(tpl, ctx)\n  }\n  public async render (tpl: Template[], scope?: object, opts?: LiquidOptions): Promise<string> {\n    return toThenable(this._render(tpl, scope, opts, false))\n  }\n  public renderSync (tpl: Template[], scope?: object, opts?: LiquidOptions): string {\n    return toValue(this._render(tpl, scope, opts, true))\n  }\n\n  public _parseAndRender (html: string, scope?: object, opts?: LiquidOptions, sync?: boolean): IterableIterator<string> {\n    const tpl = this.parse(html)\n    return this._render(tpl, scope, opts, sync)\n  }\n  public async parseAndRender (html: string, scope?: object, opts?: LiquidOptions): Promise<string> {\n    return toThenable(this._parseAndRender(html, scope, opts, false))\n  }\n  public parseAndRenderSync (html: string, scope?: object, opts?: LiquidOptions): string {\n    return toValue(this._parseAndRender(html, scope, opts, true))\n  }\n\n  public * _parseFile (file: string, opts?: LiquidOptions, sync?: boolean) {\n    const options = { ...this.options, ...normalize(opts) }\n    const paths = options.root.map(root => this.fs.resolve(root, file, options.extname))\n    if (this.fs.fallback !== undefined) {\n      const filepath = this.fs.fallback(file)\n      if (filepath !== undefined) paths.push(filepath)\n    }\n\n    for (const filepath of paths) {\n      const { cache } = options\n      if (cache) {\n        const tpls = yield cache.read(filepath)\n        if (tpls) return tpls\n      }\n      if (!(sync ? this.fs.existsSync(filepath) : yield this.fs.exists(filepath))) continue\n      const tpl = this.parse(sync ? this.fs.readFileSync(filepath) : yield this.fs.readFile(filepath), filepath)\n      if (cache) cache.write(filepath, tpl)\n      return tpl\n    }\n    throw this.lookupError(file, options.root)\n  }\n  public async parseFile (file: string, opts?: LiquidOptions): Promise<Template[]> {\n    return toThenable(this._parseFile(file, opts, false))\n  }\n  public parseFileSync (file: string, opts?: LiquidOptions): Template[] {\n    return toValue(this._parseFile(file, opts, true))\n  }\n  public async renderFile (file: string, ctx?: object, opts?: LiquidOptions) {\n    const templates = await this.parseFile(file, opts)\n    return this.render(templates, ctx, opts)\n  }\n  public renderFileSync (file: string, ctx?: object, opts?: LiquidOptions) {\n    const options = normalize(opts)\n    const templates = this.parseFileSync(file, options)\n    return this.renderSync(templates, ctx, opts)\n  }\n\n  public _evalValue (str: string, ctx: Context): IterableIterator<any> {\n    const value = new Value(str, this.filters)\n    return value.value(ctx)\n  }\n  public async evalValue (str: string, ctx: Context): Promise<any> {\n    return toThenable(this._evalValue(str, ctx))\n  }\n  public evalValueSync (str: string, ctx: Context): any {\n    return toValue(this._evalValue(str, ctx))\n  }\n\n  public registerFilter (name: string, filter: FilterImplOptions) {\n    this.filters.set(name, filter)\n  }\n  public registerTag (name: string, tag: TagImplOptions) {\n    this.tags.set(name, tag)\n  }\n  public plugin (plugin: (this: Liquid, L: typeof Liquid) => void) {\n    return plugin.call(this, Liquid)\n  }\n  public express () {\n    const self = this // eslint-disable-line\n    return function (this: any, filePath: string, ctx: object, callback: (err: Error | null, rendered: string) => void) {\n      const opts = { root: [...normalizeStringArray(this.root), ...self.options.root] }\n      self.renderFile(filePath, ctx, opts).then(html => callback(null, html) as any, callback as any)\n    }\n  }\n\n  private lookupError (file: string, roots: string[]) {\n    const err = new Error('ENOENT') as any\n    err.message = `ENOENT: Failed to lookup \"${file}\" in \"${roots}\"`\n    err.code = 'ENOENT'\n    return err\n  }\n\n  /**\n   * @deprecated use parseFile instead\n   */\n  public async getTemplate (file: string, opts?: LiquidOptions): Promise<Template[]> {\n    return this.parseFile(file, opts)\n  }\n  /**\n   * @deprecated use parseFileSync instead\n   */\n  public getTemplateSync (file: string, opts?: LiquidOptions): Template[] {\n    return this.parseFileSync(file, opts)\n  }\n}\n"],"names":["Drop","key","toStr","Object","prototype","toString","toLowerCase","String","isString","value","call","isFunction","stringify","isNil","toValue","valueOf","isNumber","isArray","forOwn","object","iteratee","k","hasOwnProperty","last","arr","length","isObject","type","range","start","stop","step","i","push","padStart","str","ch","pad","add","n","identify","val","snakeCase","replace","_","a","b","caseInsensitiveCompare","next","prev","this","LRU","cache","node","Node","head","size","ensureLimit","remove","write","tail","limit","defaultOptions","root","undefined","extname","dynamicPartials","trimTagRight","trimTagLeft","trimOutputRight","trimOutputLeft","greedy","tagDelimiterLeft","tagDelimiterRight","outputDelimiterLeft","outputDelimiterRight","strictFilters","strictVariables","globals","normalize","options","normalizeStringArray","_.isArray","_.isString","Context","defaultValue","registers","_i","keys","map","_this","getRegister","keyValues","forEach","_a","_b","setRegister","tslib_1.__spread","environments","scopes","reduce","ctx","__assign","paths","scope","findScope","getFromScope","split","path","obj","toLiquid","liquidMethodMissing","readSize","readFirst","readLast","readProperty","opts","TypeError","pop","candidate","env","sync","TokenKind","filepath","ext","base","document","createElement","href","getElementsByTagName","insertBefore","firstChild","resolved","removeChild","domResolve","origin","test","url","Promise","resolve","reject","xhr","XMLHttpRequest","onload","status","responseText","Error","statusText","onerror","open","send","isDelimitedToken","getKind","Delimited","isOperatorToken","Operator","isHTMLToken","HTML","isOutputToken","Output","isTagToken","Tag","isQuotedToken","Quoted","isLiteralToken","Literal","isNumberToken","Number","isPropertyAccessToken","PropertyAccess","isWordToken","Word","isRangeToken","Range","kind","TYPES","BLANK","INLINE_BLANK","trimLeft","token","mask","input","charCodeAt","end","trimRight","begin","charAt","Token","slice","row","col","file","tslib_1.__extends","whole","decimal","_super","WordToken","allowSign","content","getText","EmptyDrop","BlankDrop","equals","NullDrop","literalValues","true","false","nil","null","empty","blank","literal","precedence","==","!=",">","<",">=","<=","contains","and","or","OperatorToken","operator","variable","props","LiquidError","err","originalError","context","line","lines","Math","max","min","_\r\n        .range","lineNumber","_.padStart","join","mkContext","message","msg","mkMessage","stack","name","update","RenderError","tpl","assert","predicate","AssertionError","args","Filter","Hash","HTMLToken","tl","tr","trim","DelimitedToken","nameEnd","TokenizationError","argsBegin","lhs","rhs","trie","d","needBoundary","o","r","c","t","s","=","!","Tokenizer","operand","readValue","p","N","readOperator","operand_1","skipBlank","info","matchOperator","filters","filter","readFilter","peek","snapshot","readWord","arg","readFilterArg","FilterToken","tokens","readTopLevelToken","inRaw","whiteSpaceCtrl","matchWord","readTagToken","readOutputToken","readHTMLToken","readTo","mkError","TagToken","OutputToken","JSON","substr","ellipsis","peekType","hashes","hash","readHash","HashToken","reverseMatchWord","readQuoted","readRange","prop","LiteralToken","NumberToken","PropertyAccessToken","readValueOrThrow","RangeToken","escaped","QuotedToken","word","Emitter","html","Render","templates","emitter","templates_1","tslib_1.__values","render","break","continue","is","e_1","ParseStream","cb","handlers","event","h","trigger","stopRequested","shift","template","parseToken","rHex","rOct","escapeChar","f","v","hexVal","code","isComparable","isTruthy","isFalsy","operatorImpls","l","gt","lt","geq","leq","indexOf","Expression","postfix","TypeGuards.isOperatorToken","operands","result","evalOperatorToken","evalToken","evaluate","tokenizer","ops","tokens_1","getPrecedence","toPostfix","readExpression","TypeGuards.isPropertyAccessToken","get","TypeGuards.isRangeToken","low","high","evalRangeToken","TypeGuards.isLiteralToken","evalLiteralToken","TypeGuards.isNumberToken","evalNumberToken","TypeGuards.isWordToken","TypeGuards.isQuotedToken","evalQuotedToken","ret","j","fromCharCode","parseStringLiteral","markup","readHashes","TemplateImpl","impl","liquid","tags","create","parse","argv","isKeyValuePair","_d","_c","_j","_g","_f","apply","Value","initial","filterMap","readFilters","getContent","Parser","remainTokens","e","ParseError","advance","remaining","bottom","_evalValue","toEnumerable","toArray","ForloopDrop","BlockMode","toknenizer","inStr","collection","elseTemplates","stream","parser","parseStream","on","renderer","renderTemplates","offset","reverse","forloop","collection_1","item","tagToken","cond","cases","branch","readFileName","withVar","saved","saveRegister","OUTPUT","_parseFile","restoreRegister","keyword","beforeAs","alias","childCtx","_e","group","candidates","fingerprint","groups","idx","branches","tpls","STORE","blocks","partial","match","exec","block","childDefined","TablerowloopDrop","floor","cols","col0","assign","for","For","capture","case","Case","comment","include","decrement","increment","cycle","if","If","layout","raw","tablerow","tmp","tablerowloop","unless","escapeMap","&","\"","'","unescapeMap","&amp;","&lt;","&gt;","&#34;","&#39;","escape","m","abs","atLeast","atMost","ceil","rFormat","monthNames","dayNames","monthNamesShort","abbr","dayNamesShort","suffixes","1","2","3","default","getDayOfYear","num","getMonth","year","getFullYear","isLeapYear","getDate","getWeekOfYear","startDay","now","getDay","then","Date","padWidths","H","I","L","M","S","U","W","padChars","A","B","P","formatCodes","toLocaleString","C","parseInt","substring","century","getHours","getMilliseconds","getMinutes","width","padEnd","q","index","getSuffix","round","getSeconds","u","w","x","toLocaleDateString","X","toLocaleTimeString","y","Y","z","getTimezoneOffset","nOffset","flags","%","format","flagStr","modifier","conversion","convert","flagStr_1","padChar","padWidth","toUpperCase","some","changeCase","unescape","amp","pow","property","sort","decodeURIComponent","encodeURIComponent","arrayLast","concat","expected","date","isNaN","getTime","isValidDate","formatStr","output","strftime","pattern","replacement","arg1","arg2","TagMap","impls","FilterMap","mkResolve","catch","mkReject","toThenable","isThenable","throw","return","isCustomIterable","state","done","Liquid","readTopLevelTokens","_render","_parseAndRender","fs","fallback","paths_1","read","existsSync","exists","readFileSync","readFile","lookupError","parseFile","parseFileSync","renderSync","set","tag","plugin","self","filePath","callback","renderFile","roots","applyDefault","builtinTags","conf","registerTag","builtinFilters","handler","registerFilter"],"mappings":"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"}